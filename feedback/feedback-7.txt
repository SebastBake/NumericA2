============================================
vis/output.txt
03:41:27_Monday_16_October_2017
============================================

Compiling with gcc -Wall -std=c99 ... 
Compilation succeeded.
setrlimit failed.
==2897== Memcheck, a memory error detector
==2897== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
==2897== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info
==2897== Command: exec ../data/in_shock.csv ../data/in_linalsys.csv ../data/in_interp.csv 5 ../data/in_heateqn.csv
==2897== 
shockwave: 308.56 milliseconds
linalgbsys: 12.63 milliseconds
interp: 204.05 milliseconds
heateqn: 119.20 milliseconds
==2897== 
==2897== HEAP SUMMARY:
==2897==     in use at exit: 1,704 bytes in 3 blocks
==2897==   total heap usage: 14,471 allocs, 14,468 frees, 9,635,312 bytes allocated
==2897== 
==2897== LEAK SUMMARY:
==2897==    definitely lost: 0 bytes in 0 blocks
==2897==    indirectly lost: 0 bytes in 0 blocks
==2897==      possibly lost: 0 bytes in 0 blocks
==2897==    still reachable: 1,704 bytes in 3 blocks
==2897==         suppressed: 0 bytes in 0 blocks
==2897== Rerun with --leak-check=full to see details of leaked memory
==2897== 
==2897== For counts of detected and suppressed errors, rerun with: -v
==2897== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 6 from 6)
============================================
Test for input file: 
Files ../data/out_shock.csv and out_shock.csv differ
 
Oops, your shock solution seems to be INCORRECT.  :(
 
 
Your algebraic systems seems to be CORRECT.  :)
 
 
Your interpolation seems to be CORRECT.  :)
 
 
Your heat eqn explicit fixed ends seems to be CORRECT.  :)
 
 
Your heat eqn explicit variable ends seems to be CORRECT.  :)
 
 
Your heat eqn implicit fixed ends seems to be CORRECT.  :)
 
============================================
vis/sebastianb1-output.txt
03:41:27_Monday_16_October_2017
============================================
======================================================
                    SHOCK WAVE                        
======================================================
M,theta,beta_lower,beta_upper
2.0000,0,30.0000,90.0000
2.0000,1,30.8114,89.3997
2.0000,2,31.6463,88.7978
2.0000,3,32.5055,88.1926
2.0000,4,33.3902,87.5823
2.0000,5,34.3016,86.9651
2.0000,6,35.2409,86.3391
2.0000,7,36.2098,85.7021
2.0000,8,37.2101,85.0518
2.0000,9,38.2440,84.3855
2.0000,10,39.3139,83.7001
2.0000,11,40.4231,82.9920
2.0000,12,41.5752,82.2570
2.0000,13,42.7750,81.4899
2.0000,14,44.0286,80.6842
2.0000,15,45.3436,79.8317
2.0000,16,46.7306,78.9214
2.0000,17,48.2041,77.9385
2.0000,18,49.7851,76.8615
2.0000,19,51.5063,75.6573
2.0000,20,53.4229,74.2701
2.0000,21,55.6443,72.5905
2.0000,22,58.4566,70.3316
4.0000,0,14.4775,90.0000
4.0000,1,15.1313,89.7199
4.0000,2,15.8126,89.4395
4.0000,3,16.5215,89.1584
4.0000,4,17.2578,88.8762
4.0000,5,18.0213,88.5926
4.0000,6,18.8117,88.3071
4.0000,7,19.6287,88.0195
4.0000,8,20.4717,87.7292
4.0000,9,21.3404,87.4359
4.0000,10,22.2341,87.1391
4.0000,11,23.1525,86.8384
4.0000,12,24.0950,86.5332
4.0000,13,25.0611,86.2230
4.0000,14,26.0505,85.9072
4.0000,15,27.0629,85.5851
4.0000,16,28.0979,85.2561
4.0000,17,29.1555,84.9194
4.0000,18,30.2356,84.5742
4.0000,19,31.3383,84.2195
4.0000,20,32.4639,83.8542
4.0000,21,33.6128,83.4771
4.0000,22,34.7857,83.0870
4.0000,23,35.9835,82.6820
4.0000,24,37.2074,82.2606
4.0000,25,38.4589,81.8204
4.0000,26,39.7400,81.3590
4.0000,27,41.0533,80.8733
4.0000,28,42.4021,80.3594
4.0000,29,43.7905,79.8128
4.0000,30,45.2241,79.2275
4.0000,31,46.7101,78.5959
4.0000,32,48.2585,77.9075
4.0000,33,49.8833,77.1482
4.0000,34,51.6052,76.2967
4.0000,35,53.4569,75.3202
4.0000,36,55.4957,74.1611
4.0000,37,57.8390,72.7016
4.0000,38,60.8271,70.6012
6.0000,0,9.5941,90.0000
6.0000,1,10.2307,89.7657
6.0000,2,10.9063,89.5311
6.0000,3,11.6204,89.2960
6.0000,4,12.3719,89.0600
6.0000,5,13.1598,88.8231
6.0000,6,13.9824,88.5847
6.0000,7,14.8382,88.3448
6.0000,8,15.7254,88.1029
6.0000,9,16.6422,87.8588
6.0000,10,17.5869,87.6121
6.0000,11,18.5576,87.3626
6.0000,12,19.5529,87.1098
6.0000,13,20.5712,86.8533
6.0000,14,21.6112,86.5929
6.0000,15,22.6719,86.3279
6.0000,16,23.7521,86.0580
6.0000,17,24.8511,85.7827
6.0000,18,25.9683,85.5014
6.0000,19,27.1031,85.2134
6.0000,20,28.2551,84.9182
6.0000,21,29.4244,84.6149
6.0000,22,30.6108,84.3028
6.0000,23,31.8147,83.9809
6.0000,24,33.0363,83.6481
6.0000,25,34.2763,83.3033
6.0000,26,35.5356,82.9452
6.0000,27,36.8152,82.5720
6.0000,28,38.1167,82.1819
6.0000,29,39.4417,81.7728
6.0000,30,40.7925,81.3420
6.0000,31,42.1721,80.8864
6.0000,32,43.5839,80.4020
6.0000,33,45.0327,79.8840
6.0000,34,46.5244,79.3262
6.0000,35,48.0671,78.7202
6.0000,36,49.6715,78.0551
6.0000,37,51.3535,77.3149
6.0000,38,53.1363,76.4762
6.0000,39,55.0581,75.5006
6.0000,40,57.1883,74.3186
6.0000,41,59.6820,72.7749
6.0000,42,63.1049,70.3039
8.0000,0,7.1808,90.0000
8.0000,1,7.8159,89.7809
8.0000,2,8.5017,89.5616
8.0000,3,9.2370,89.3418
8.0000,4,10.0193,89.1213
8.0000,5,10.8460,88.8998
8.0000,6,11.7138,88.6771
8.0000,7,12.6192,88.4530
8.0000,8,13.5588,88.2272
8.0000,9,14.5296,87.9993
8.0000,10,15.5284,87.7691
8.0000,11,16.5526,87.5364
8.0000,12,17.5998,87.3008
8.0000,13,18.6679,87.0619
8.0000,14,19.7553,86.8194
8.0000,15,20.8605,86.5730
8.0000,16,21.9822,86.3222
8.0000,17,23.1195,86.0665
8.0000,18,24.2717,85.8056
8.0000,19,25.4382,85.5388
8.0000,20,26.6187,85.2656
8.0000,21,27.8130,84.9854
8.0000,22,29.0211,84.6975
8.0000,23,30.2432,84.4010
8.0000,24,31.4796,84.0952
8.0000,25,32.7307,83.7789
8.0000,26,33.9974,83.4512
8.0000,27,35.2805,83.1107
8.0000,28,36.5812,82.7559
8.0000,29,37.9010,82.3851
8.0000,30,39.2415,81.9963
8.0000,31,40.6050,81.5870
8.0000,32,41.9942,81.1543
8.0000,33,43.4125,80.6947
8.0000,34,44.8641,80.2037
8.0000,35,46.3546,79.6756
8.0000,36,47.8911,79.1031
8.0000,37,49.4834,78.4765
8.0000,38,51.1452,77.7818
8.0000,39,52.8963,76.9990
8.0000,40,54.7684,76.0966
8.0000,41,56.8161,75.0196
8.0000,42,59.1517,73.6558
8.0000,43,62.0971,71.6834
======================================================
                 LINEAR ALG SYSTEMS                   
======================================================
x
64.6047
-12.5209
-19.5988
-16.5714
6.9928
-9.2393
======================================================
                  INTERPOLATION                       
======================================================
lagrange
19.5714
cubic
17.2400
======================================================
           HEAT EQN EXPLICIT FIXED ENDS               
======================================================
x,f(x)
0.0000,0.0000
0.0100,0.0086
0.0200,0.0176
0.0300,0.0275
0.0400,0.0386
0.0500,0.0513
0.0600,0.0658
0.0700,0.0826
0.0800,0.1019
0.0900,0.1236
0.1000,0.1480
0.1100,0.1749
0.1200,0.2042
0.1300,0.2355
0.1400,0.2685
0.1500,0.3024
0.1600,0.3368
0.1700,0.3707
0.1800,0.4034
0.1900,0.4341
0.2000,0.4618
0.2100,0.4857
0.2200,0.5052
0.2300,0.5196
0.2400,0.5284
0.2500,0.5314
0.2600,0.5284
0.2700,0.5196
0.2800,0.5052
0.2900,0.4857
0.3000,0.4618
0.3100,0.4341
0.3200,0.4034
0.3300,0.3707
0.3400,0.3368
0.3500,0.3025
0.3600,0.2685
0.3700,0.2356
0.3800,0.2044
0.3900,0.1752
0.4000,0.1484
0.4100,0.1242
0.4200,0.1027
0.4300,0.0840
0.4400,0.0678
0.4500,0.0540
0.4600,0.0426
0.4700,0.0331
0.4800,0.0254
0.4900,0.0193
0.5000,0.0144
0.5100,0.0107
0.5200,0.0078
0.5300,0.0056
0.5400,0.0040
0.5500,0.0028
0.5600,0.0019
0.5700,0.0013
0.5800,0.0009
0.5900,0.0006
0.6000,0.0004
0.6100,0.0002
0.6200,0.0002
0.6300,0.0001
0.6400,0.0001
0.6500,0.0000
0.6600,0.0000
0.6700,0.0000
0.6800,0.0000
0.6900,0.0000
0.7000,0.0000
0.7100,0.0000
0.7200,0.0000
0.7300,0.0000
0.7400,0.0000
0.7500,0.0000
0.7600,0.0000
0.7700,0.0000
0.7800,0.0000
0.7900,0.0000
0.8000,0.0000
0.8100,0.0000
0.8200,0.0000
0.8300,0.0000
0.8400,0.0000
0.8500,0.0000
0.8600,0.0000
0.8700,0.0000
0.8800,0.0000
0.8900,0.0000
0.9000,0.0000
0.9100,0.0000
0.9200,0.0000
0.9300,0.0000
0.9400,0.0000
0.9500,0.0000
0.9600,0.0000
0.9700,0.0000
0.9800,0.0000
0.9900,0.0000
1.0000,0.0000
======================================================
          HEAT EQN EXPLICIT VARIABLE ENDS             
======================================================
x,f(x)
0.0000,0.0337
0.0100,0.0337
0.0200,0.0361
0.0300,0.0409
0.0400,0.0482
0.0500,0.0580
0.0600,0.0706
0.0700,0.0859
0.0800,0.1041
0.0900,0.1251
0.1000,0.1490
0.1100,0.1756
0.1200,0.2046
0.1300,0.2358
0.1400,0.2686
0.1500,0.3025
0.1600,0.3368
0.1700,0.3707
0.1800,0.4035
0.1900,0.4341
0.2000,0.4618
0.2100,0.4857
0.2200,0.5052
0.2300,0.5196
0.2400,0.5284
0.2500,0.5314
0.2600,0.5284
0.2700,0.5196
0.2800,0.5052
0.2900,0.4857
0.3000,0.4618
0.3100,0.4341
0.3200,0.4034
0.3300,0.3707
0.3400,0.3368
0.3500,0.3025
0.3600,0.2685
0.3700,0.2356
0.3800,0.2044
0.3900,0.1752
0.4000,0.1484
0.4100,0.1242
0.4200,0.1027
0.4300,0.0840
0.4400,0.0678
0.4500,0.0540
0.4600,0.0426
0.4700,0.0331
0.4800,0.0254
0.4900,0.0193
0.5000,0.0144
0.5100,0.0107
0.5200,0.0078
0.5300,0.0056
0.5400,0.0040
0.5500,0.0028
0.5600,0.0019
0.5700,0.0013
0.5800,0.0009
0.5900,0.0006
0.6000,0.0004
0.6100,0.0002
0.6200,0.0002
0.6300,0.0001
0.6400,0.0001
0.6500,0.0000
0.6600,0.0000
0.6700,0.0000
0.6800,0.0000
0.6900,0.0000
0.7000,0.0000
0.7100,0.0000
0.7200,0.0000
0.7300,0.0000
0.7400,0.0000
0.7500,0.0000
0.7600,0.0000
0.7700,0.0000
0.7800,0.0000
0.7900,0.0000
0.8000,0.0000
0.8100,0.0000
0.8200,0.0000
0.8300,0.0000
0.8400,0.0000
0.8500,0.0000
0.8600,0.0000
0.8700,0.0000
0.8800,0.0000
0.8900,0.0000
0.9000,0.0000
0.9100,0.0000
0.9200,0.0000
0.9300,0.0000
0.9400,0.0000
0.9500,0.0000
0.9600,0.0000
0.9700,0.0000
0.9800,0.0000
0.9900,0.0000
1.0000,0.0000
======================================================
          HEAT EQN IMPLICIT FIXED ENDS             
======================================================
x,f(x)
0.0000,0.0000
0.0100,0.0085
0.0200,0.0175
0.0300,0.0272
0.0400,0.0382
0.0500,0.0507
0.0600,0.0652
0.0700,0.0818
0.0800,0.1008
0.0900,0.1224
0.1000,0.1467
0.1100,0.1735
0.1200,0.2028
0.1300,0.2341
0.1400,0.2672
0.1500,0.3014
0.1600,0.3360
0.1700,0.3703
0.1800,0.4035
0.1900,0.4345
0.2000,0.4627
0.2100,0.4871
0.2200,0.5069
0.2300,0.5215
0.2400,0.5305
0.2500,0.5336
0.2600,0.5305
0.2700,0.5215
0.2800,0.5069
0.2900,0.4871
0.3000,0.4627
0.3100,0.4346
0.3200,0.4035
0.3300,0.3703
0.3400,0.3360
0.3500,0.3014
0.3600,0.2673
0.3700,0.2343
0.3800,0.2030
0.3900,0.1738
0.4000,0.1472
0.4100,0.1231
0.4200,0.1018
0.4300,0.0833
0.4400,0.0673
0.4500,0.0537
0.4600,0.0424
0.4700,0.0331
0.4800,0.0255
0.4900,0.0195
0.5000,0.0147
0.5100,0.0109
0.5200,0.0081
0.5300,0.0059
0.5400,0.0042
0.5500,0.0030
0.5600,0.0021
0.5700,0.0015
0.5800,0.0010
0.5900,0.0007
0.6000,0.0005
0.6100,0.0003
0.6200,0.0002
0.6300,0.0001
0.6400,0.0001
0.6500,0.0001
0.6600,0.0000
0.6700,0.0000
0.6800,0.0000
0.6900,0.0000
0.7000,0.0000
0.7100,0.0000
0.7200,0.0000
0.7300,0.0000
0.7400,0.0000
0.7500,0.0000
0.7600,0.0000
0.7700,0.0000
0.7800,0.0000
0.7900,0.0000
0.8000,0.0000
0.8100,0.0000
0.8200,0.0000
0.8300,0.0000
0.8400,0.0000
0.8500,0.0000
0.8600,0.0000
0.8700,0.0000
0.8800,0.0000
0.8900,0.0000
0.9000,0.0000
0.9100,0.0000
0.9200,0.0000
0.9300,0.0000
0.9400,0.0000
0.9500,0.0000
0.9600,0.0000
0.9700,0.0000
0.9800,0.0000
0.9900,0.0000
1.0000,0.0000
======================================================
============================================
src/interpolate.h
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : interpolate.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "thomas_alg.h"

#ifndef INTERPOLATE_H

#define INTERP_INIT_ARRLEN 20
#define QUADRATIC_NUM_PTS 3
#define CUB_SPLINE_COMPUTE_SUCCESS 1
#define CUB_SPLINE_COMPUTE_FAIL -1
#define TINY(x) fabs(x) < 1e-11
#define CUB_SPLINE_B(h_1, a_1, a_2, c_1, c_2) (a_2-a_1)/h_1 - h_1*(2.0*c_1+c_2)/3.0
#define CUB_SPLINE_C_RHS(h_0, h_1, a_0, a_1, a_2) 3.0*(a_2-a_1)/h_1 + 3.0*(a_0-a_1)/h_0
#define CUB_SPLINE_C_a(h_1, h_0) 2.0*(h_1+h_0)
#define CUB_SPLINE_D(h_1, c_1, c_2) (c_2-c_1)/(3.0*h_1)
#define EVAL_CUB_SPLINE(a,b,c,d,x_i,x) a + b*(x-x_i) + c*pow(x-x_i,2) + d*pow(x-x_i,3)

typedef struct interp_pt {

	double x;
	double fx;

} interp_pt_t;

typedef struct interp_set {

	interp_pt_t** pts;
	int N;
	int arrLen;

} interp_set_t;

typedef struct lagrange_term {

	int index;
	int order;
	double* root;
	double fx_i;
	double denominator;

} lagrange_term_t;

typedef struct lagrange_eqn {

	lagrange_term_t** terms;
	int num_terms;

} lagrange_eqn_t;

typedef struct cub_spline_segment {

	int index;
	double x_lo;
	double a;
	double b;
	double c;
	double d;

} cub_spline_seg_t;

typedef struct cub_spline {

	cub_spline_seg_t** segs;
	int num_segs; // not including the unused/incomplete end segment eg: 4 points means 3 segments

} cub_spline_t;

interp_set_t* newInterpSet();
interp_pt_t* newInterpPt(double x, double fx);
void freeInterpSet(interp_set_t* set);
void freeInterpPt(interp_pt_t* pt);
void appendPtToSet(interp_set_t* set, interp_pt_t* pt);

lagrange_term_t* newLagrangeTerm(interp_set_t* set, int index);
lagrange_eqn_t* newLagrangeEqn(interp_set_t* set);
void freeLagrangeEqn(lagrange_eqn_t* eqn);
void freeLagrangeTerm(lagrange_term_t* term);
interp_pt_t* evaluateLagrangeEqn(lagrange_eqn_t* eqn, double x);
double evaluateLagrangeTerm(lagrange_term_t* term, double x);

cub_spline_t* newCubSpline(interp_set_t* set);
cub_spline_seg_t* newEmptyCubSplineSegment(int index, double x_lo);
void freeCubSpline(cub_spline_t* spline);
void freeCubSplineSegment(cub_spline_seg_t* seg);
double splineH(int index, cub_spline_t* spline);
int computeCubSplineConstants(interp_set_t* set, cub_spline_t* spline);
int computeCubSplineAs(interp_set_t* set, cub_spline_t* spline);
int computeCubSplineBs(interp_set_t* set, cub_spline_t* spline);
int computeCubSplineCs(interp_set_t* set, cub_spline_t* spline);
int computeCubSplineDs(interp_set_t* set, cub_spline_t* spline);
interp_pt_t* evaluateCubSpline(cub_spline_t* spline, double x);
interp_pt_t* evaluateCubSplineSegment(cub_spline_seg_t* seg, double x);

#endif============================================
src/tasks.c
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : tasks.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "tasks.h"

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * TASK FUNCTIONS */

void shockwave(const char* filename) {

	input_2_t *parsed = parseInput_2(filename);
	shockwave_2a(parsed);
	shockwave_2b(parsed);
	shockwave_2c(parsed);
	freeInput_2(parsed);
}

void linalgbsys(const char* filename) {

	tridiag_t *m = parseInput_3(filename);
	assert(solveTridiag(m) == SOLVER_SUCCESS);
	printTridiag_3(m);
	freeTridiag(m);
}

void interp(const char* filename, const double xo) {
	
	interp_set_t* set = parseInput_5(filename);
	cub_spline_t* spline = newCubSpline(set);

	// generates data for plot
	// plotInterpAnyOrder_5(lagEqn, spline);
	plotInterpQuadratic_5(set, spline);

	// calculate the interpolated values at xo
	interp_pt_t* lagEval = evaluateQuadLagrangeEqn(set, xo);
	interp_pt_t* splineEval = evaluateCubSpline(spline, xo);
	printInterp_5(lagEval->fx, splineEval->fx);
	freeInterpPt(lagEval);
	freeInterpPt(splineEval);

	freeCubSpline(spline);
	freeInterpSet(set);
}

void heateqn(const char* filename) {

	heat_sim_t* exFe = parseInput_6(filename);
	eulerExFe(exFe);
	printSim_6(exFe, FILENAME_EX_FE_6);
	freeHeatSim(exFe);

	heat_sim_t* exVe = parseInput_6(filename);
	eulerExVe(exVe);
	printSim_6(exVe, FILENAME_EX_VE_6);
	freeHeatSim(exVe);

	heat_sim_t* imFe = parseInput_6(filename);
	eulerImFe(imFe);
	printSim_6(imFe, FILENAME_IM_FE_6);
	freeHeatSim(imFe);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * *  HEATEQN HELPER FUNCTIONS */

heat_sim_t* parseInput_6(const char* filename) {

	assert(filename!=NULL);

	// open file
	FILE* fp = fopen(filename, FILE_READONLY);
	assert(fp != NULL);

	double mu;
	int Nx, Nt;

	fscanf(fp, IN_HEADER_6);
	assert(fscanf(fp,"%lf,%d,%d\n", &mu, &Nx, &Nt) == NUM_PARAMS_6);
	fclose(fp);
	
	return newUnsolvedHeatSim(
		Nx, Nt, X_LO_6, X_HI_6, T_LO_6, T_HI_6, mu, myInitialCondition_6 );
}

double myInitialCondition_6(double x) {

	if(x>=IC_LO_6 && x<=IC_HI_6) {
		return IC_6(x);
	}
	return 0.0;
}

void printSim_6(heat_sim_t* sim, const char* filename) {
	
	assert(sim!=NULL);
	assert(filename!=NULL);

	sim_cell_t** m = sim->cells; // cell matrix

	FILE* fp = fopen(filename, FILE_OVERWRITE);
	assert(fp!=NULL);

	fprintf(fp, OUT_HEADER_6);

	int i=0;
	int j=100;
	for(i=0; i<=sim->Nx; i++) {
		fprintf(fp, "%.4f,%.4f\n", m[i][j].x, m[i][j].f);
    }
}


/* * * * * * * * * * * * * * * * * * * * * * * * * *  INTERP HELPER FUNCTIONS */

interp_set_t* parseInput_5(const char* filename) {

	assert(filename!=NULL);

	interp_set_t* newSet = newInterpSet(); 

	// open file
	FILE* fp = fopen(filename, FILE_READONLY);
	assert(fp != NULL);

	double tmp_x, tmp_fx;
	fscanf(fp, IN_HEADER_5);
	int read = 0;
	int i=0;
	while(1) {
		read = fscanf(fp,"%lf,%lf\n", &tmp_x, &tmp_fx);
		if(read != NUM_PARAMS_5) { break; }
		appendPtToSet(newSet, newInterpPt(tmp_x, tmp_fx) );
		i++;
	}

	fclose(fp);

	return newSet;
}

interp_pt_t* evaluateQuadLagrangeEqn(interp_set_t* set, double xo) {

	// require at least 3 points to make a quadratic
	assert(set->N >= QUADRATIC_NUM_PTS);

	interp_set_t* newSet = newInterpSet();

	// insert the 3 closest points to xo into a new set to make the quadratic
	interp_pt_t* p1 = set->pts[0];
	double p1_diff = DBL_MAX;
	interp_pt_t* p2 = set->pts[0];
	double p2_diff = DBL_MAX;
	interp_pt_t* p3 = set->pts[0];
	double p3_diff = DBL_MAX;

	int i = 0;
	for(i=0; i < set->N ; i++) {
		if(p1_diff >= fabs(set->pts[i]->x-xo)) {
			p1 = set->pts[i];
			p1_diff = fabs(p1->x-xo);
		}
	}

	for(i=0; i < set->N ; i++) {
		if(
			p2_diff >= fabs(set->pts[i]->x-xo) &&
			set->pts[i] != p1
		) {
			p2 = set->pts[i];
			p2_diff = fabs(p2->x-xo);
		}
	}

	for(i=0; i < set->N ; i++) {
		if(
			p3_diff >= fabs(set->pts[i]->x-xo) && 
			set->pts[i] != p1 &&
			set->pts[i] != p2
		) {
			p3 = set->pts[i];
			p3_diff = fabs(p3->x-xo);
		}
	}

	appendPtToSet(newSet, newInterpPt(p1->x, p1->fx));
	appendPtToSet(newSet, newInterpPt(p2->x, p2->fx));
	appendPtToSet(newSet, newInterpPt(p3->x, p3->fx));

	// generate & evaluate the equation
	lagrange_eqn_t* lagEqn = newLagrangeEqn(newSet);
	interp_pt_t* lagEval = evaluateLagrangeEqn(lagEqn, xo);
	freeLagrangeEqn(lagEqn);
	freeInterpSet(newSet);

	return lagEval;
}

void printInterp_5(double lag, double spline) {

	// open file
	FILE* fp = fopen(FILENAME_5, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp, HEADER_LAGRANGE_5);
	fprintf(fp, "%.4f\n", lag);
	fprintf(fp, HEADER_CUBIC_5);
	fprintf(fp, "%.4f\n", spline);

	fclose(fp);
}

void plotInterpAnyOrder_5(lagrange_eqn_t* lagEqn, cub_spline_t* spline) {

	// open file
	FILE* fp = fopen(PLOT_FILENAME_ANY_ORDER_5, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp, PLOT_HEADER_LAGRANGE_5);

	double x = PLOT_START_5;
	interp_pt_t* tmp_pt;
	while(x < PLOT_END_5) {

		fprintf(fp, "%.4f,", x);
		tmp_pt = evaluateLagrangeEqn(lagEqn, x);
		fprintf(fp, "%.4f,", tmp_pt->fx);
		freeInterpPt(tmp_pt);
		tmp_pt = evaluateCubSpline(spline, x);
		fprintf(fp, "%.4f\n", tmp_pt->fx);
		freeInterpPt(tmp_pt);
		x = x + PLOT_INTERVAL_5;
	}

	fclose(fp);
}

void plotInterpQuadratic_5(interp_set_t* set, cub_spline_t* spline) {

	// open file
	FILE* fp = fopen(PLOT_FILENAME_QUADRATIC_5, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp, PLOT_HEADER_LAGRANGE_5);

	double x = PLOT_START_5;
	interp_pt_t* tmp_pt;
	while(x < PLOT_END_5) {

		fprintf(fp, "%.4f,", x);
		tmp_pt = evaluateQuadLagrangeEqn(set, x);
		fprintf(fp, "%.4f,", tmp_pt->fx);
		freeInterpPt(tmp_pt);
		tmp_pt = evaluateCubSpline(spline, x);
		fprintf(fp, "%.4f\n", tmp_pt->fx);
		freeInterpPt(tmp_pt);
		x = x + PLOT_INTERVAL_5;
	}

	fclose(fp);
}


/* * * * * * * * * * * * * * * * * * * * * * * * LINALGBYSYS HELPER FUNCTIONS */

tridiag_t *parseInput_3(const char* filename) {
	
	assert(filename!=NULL);

	tridiag_t *m = newTridiag();

	// open file
	FILE* fp = fopen(filename, FILE_READONLY);
	assert(fp != NULL);

	double tmp_a, tmp_b, tmp_c, tmp_q;
	fscanf(fp, IN_HEADER_3);
	int read = 0;
	while(1) {
		read = fscanf(fp,"%lf,%lf,%lf,%lf\n", &tmp_a, &tmp_b, &tmp_c, &tmp_q);
		if(read != NUM_PARAMS_3) { break; }
		appendTridiagRow(m,tmp_a, tmp_b, tmp_c, tmp_q);
	}

	fclose(fp);
	return m;
}

void printTridiag_3(tridiag_t *m) {

	assert(m!=NULL);

	FILE* fp = fopen(FILENAME_3, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp, FILE_HEADER_3);
	int i=1;
	for(i=1; i <= m->N; i++) {
		tridiag_row_t *r = getTridiagRow(m, i);
		fprintf(fp,"%.4f\n",r->x);
	}

	fclose(fp);
}


/* * * * * * * * * * * * * * * * * * * * * * * * * SHOCKWAVE HELPER FUNCTIONS */

input_2_t *parseInput_2(const char* filename) {
	
	assert(filename!=NULL);
	
	// allocate memory
	input_2_t *parsed = (input_2_t*)malloc(sizeof(input_2_t));
	assert(parsed != NULL);
	parsed->M_c = (double*)calloc(M_LEN_2C, sizeof(double));
	assert(parsed->M_c != NULL);

	// open file
	FILE* fp = fopen(filename, FILE_READONLY);
	assert(fp != NULL);

	// parse file
	parseInput2ndLine_2(fp, parsed);
	parseInputMvals_2(fp, parsed);

	fclose(fp);
	return parsed;
}

void parseInput2ndLine_2(FILE* fp, input_2_t* parsed) {
	
	assert(parsed!=NULL && fp!= NULL);

	fscanf(fp, IN_1ST_HEADER_2);

	assert(NUM_PARAMS_2 == fscanf(
		fp,
		"%lf,%lf,%lf,%lf,%lf\n",
		&(parsed->M_a),
		&(parsed->t_a),
		&(parsed->b_l_a),
		&(parsed->b_u_a),
		&(parsed->g_a)
	) );
}

void parseInputMvals_2(FILE* fp, input_2_t* parsed) {
	
	assert(parsed!=NULL && fp!= NULL);

	fscanf(fp, IN_2ND_HEADER_2);

	int i=0;
	int arrayLength = M_LEN_2C;
	while( 1 == fscanf(fp,"%lf", &(parsed->M_c[i])) ) {

		// Extend array if necessary
		if(i >= arrayLength) {
			arrayLength += M_LEN_2C;
			parsed->M_c = (double*)realloc(parsed->M_c, arrayLength*sizeof(double));
			assert(parsed->M_c != NULL);
		}
		i++;
	}
	parsed->num_M_c = i;
}

void freeInput_2(input_2_t *parsed) {

	assert(parsed!=NULL);
	free(parsed->M_c);
	free(parsed);
}

double f_2(double beta, double* params) {

	assert(params!=NULL);
	return F_2( beta, params[F_M_2], params[F_T_2], params[F_G_2]);
}

void shockwave_2a(const input_2_t *parsed) {

	assert(parsed!=NULL);

	double b_l = DEG2RAD(parsed->b_l_a);
	double b_u = DEG2RAD(parsed->b_u_a);
	double params[] = {
		parsed->M_a,
		DEG2RAD(parsed->t_a),
		parsed->g_a
	};

	int b_l_itr = newtonRaphson(&b_l, params, f_2);
	int b_u_itr = newtonRaphson(&b_u, params, f_2);
	assert( b_l_itr != ROOTFIND_FAIL && b_u_itr != ROOTFIND_FAIL);

	//printf("shockwave_2a: b_l=%.5f (Should be 29.80092), after %d iterations\n", RAD2DEG(b_l), b_l_itr);
	//printf("shockwave_2a: b_u=%.5f (Should be 84.55625), after %d iterations\n", RAD2DEG(b_u), b_u_itr);
}

void shockwavePrintThetaRange_2bc(FILE* fp, double* params) {

	int b_u_itr=0, b_l_itr=0;
	double b_l = DEG2RAD(B_l_GUESS_2), b_u = DEG2RAD(B_u_GUESS_2);

	while(1) {
		b_l_itr = newtonRaphson(&b_l, params, f_2);
		b_u_itr = newtonRaphson(&b_u, params, f_2);
		if( b_l_itr == ROOTFIND_FAIL || b_u_itr == ROOTFIND_FAIL) { break; }
		
		fprintf(fp, "%.4f,%.0f,%.4f,%.4f\n",
			params[F_M_2],
			RAD2DEG(params[F_T_2]),
			RAD2DEG(b_l),
			RAD2DEG(b_u)
		);

		params[F_T_2] += RADIAN_INCREMENT_2B;
	}
}

void shockwave_2b(const input_2_t *parsed) {

	assert(parsed!=NULL);

	double params[] = { parsed->M_a, RADIAN_START_2B, parsed->g_a };

	FILE* fp = fopen(FILENAME_2B, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp,FILE_HEADER_2BC);
	shockwavePrintThetaRange_2bc( fp, params );

	fclose(fp);
}

void shockwave_2c(const input_2_t *parsed) {

	assert(parsed!=NULL);	

	FILE* fp = fopen(FILENAME_2C, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp,FILE_HEADER_2BC);
	
	int i=0;
	for(i=0; i<parsed->num_M_c; i++) {
		double params[] = { parsed->M_c[i], RADIAN_START_2B, parsed->g_a };
		shockwavePrintThetaRange_2bc( fp, params);
	}

	fclose(fp);
}

============================================
src/heat_sim.h
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : heat_sim.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "thomas_alg.h"

#ifndef HEAT_SIM_H

#define EXPLICIT_RHS(mu, dx, f_0, f_1, f_2) mu*(f_2 - 2.0*f_1 + f_0)/(dx*dx)

typedef struct heat_cell {

    double f;
    double x;
    double t;

} sim_cell_t;

typedef struct heat_sim {

    sim_cell_t** cells;
    double mu;
    double x_lo;
    double x_hi;
    double t_lo;
    double t_hi;
    int Nx;  // not including 0th x value
    int Nt; // not including 0th t value

} heat_sim_t;

heat_sim_t* newUnsolvedHeatSim(
    int Nx, 
    int Nt, 
    double x_lo, 
    double x_hi,
    double t_lo,
    double t_hi,
    double mu, 
    double (*init)(double x) 
);

void freeHeatSim(heat_sim_t* sim);
void eulerExFe(heat_sim_t* sim);
void eulerExVe(heat_sim_t* sim);
void eulerImFe(heat_sim_t* sim);


#endif ============================================
src/thomas_alg.c
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : thomas_alg.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "thomas_alg.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>

tridiag_t *newTridiag() {
	
	tridiag_t *m = (tridiag_t*)malloc(sizeof(tridiag_t));
	assert(m != NULL);

	m->arrLen = THOMAS_INIT_ARR_LEN;
	m->N = 0;

	m->rows = (tridiag_row_t*)calloc( m->arrLen, sizeof(tridiag_row_t));
	assert(m->rows != NULL);

	return m;
}

void freeTridiag(tridiag_t *m) {
	
	assert(m!=NULL);
	free(m->rows);
	free(m);
}

void appendTridiagRow(tridiag_t *m, double a, double b, double c, double Q) {

	assert(m!=NULL);	

	m->N++;
	if(m->N == m->arrLen) {
		m->arrLen += THOMAS_INIT_ARR_LEN;
		m->rows = (tridiag_row_t*)realloc( m->rows, m->arrLen*sizeof(tridiag_row_t));
		assert(m->rows!=NULL);
	}

	tridiag_row_t *r = getTridiagRow(m, m->N);
	r->a = a;
	r->b = b;
	r->c = c;
	r->Q = Q;
}

tridiag_row_t *getTridiagRow(tridiag_t *m, int i) {
	assert(m!=NULL);
	assert(i<=m->N);
	return &(m->rows[i-1]);
}

int solveTridiag(tridiag_t *m) {

	assert(m!=NULL);
	
	if(
		computeTridiag_a_s(m) == SOLVER_SUCCESS &&
		computeTridiag_Q_s(m) == SOLVER_SUCCESS &&
		computeTrigiag_x(m) == SOLVER_SUCCESS
	) {
		return SOLVER_SUCCESS;
	}

	return SOLVER_FAIL;
}

int computeTridiag_a_s(tridiag_t *m) {

	assert(m!=NULL);

	// case for row 1 : a_s = a
	int i=COMPUTE_A_S_START;
	tridiag_row_t *r = getTridiagRow(m, i);	
	tridiag_row_t *rPrev = r;
	r->a_s = r->a;

	// case for row 2,3,4...N : a_s = a − c * bPrev / a_sPrev
	while(++i <= m->N) {
		rPrev = r;
		r = getTridiagRow(m, i);
		if(TINY(rPrev->a_s)) { return SOLVER_FAIL; }
		r->a_s = r->a - r->c * rPrev->b / rPrev->a_s;
	}

	return SOLVER_SUCCESS;
}

int computeTridiag_Q_s(tridiag_t *m) {
	
	assert(m!=NULL);

	// case for row 1 : Q_s = Q
	int i=COMPUTE_Q_S_START;
	tridiag_row_t *r = getTridiagRow(m, i);	
	tridiag_row_t *rPrev = r;
	r->Q_s = r->Q;

	// case for row 2,3,4...N : Q − c * Q_sPrev /a_sPrev
	while(++i <= m->N) {
		rPrev = r;
		r = getTridiagRow(m, i);
		if(TINY(rPrev->a_s)) { return SOLVER_FAIL; }
		r->Q_s = r->Q - r->c * rPrev->Q_s / rPrev->a_s;
	}

	return SOLVER_SUCCESS;
}

int computeTrigiag_x(tridiag_t *m) {
	
	assert(m!=NULL);
	
	// case for row N : x = Q_s/a_s
	int i=m->N;
	tridiag_row_t *r = getTridiagRow(m, i);	
	tridiag_row_t *rPrev = r;
	r->x = r->Q_s/r->a_s;

	// case for row N-1, N-2, N-3...1 : x = ( Q_s − b * xPrev ) / a_s
	while(--i >= COMPUTE_x_END) {
		rPrev = r;
		r = getTridiagRow(m, i);
		if(TINY(rPrev->a_s)) { return SOLVER_FAIL; }
		r->x = (r->Q_s - r->b * rPrev->x) / r->a_s;
	}

	return SOLVER_SUCCESS;
}============================================
src/newton_raphson.c
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : newton_raphson.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "newton_raphson.h"


int newtonRaphson(double* xi, double* params, double (*f)(double, double*)) {

    double fx = f((*xi), params);

    int i=0;
    while( (i < MAX_ITERATIONS) && (fabs(fx) > EPS) ) {

        fx = f((*xi), params);
        (*xi) = (*xi) - fx / dfdx((*xi), params, f);

        i++;
    }

    if (fabs(fx) > EPS) { 
        return ROOTFIND_FAIL;
    }

    return i;
}

double dfdx(double x, double* params, double (*f)(double, double*)) {

    double df = f(x+DX/2, params) - f(x-DX/2, params);
    return df/(DX);
}============================================
src/interpolate.c
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : interpolate.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "interpolate.h"

// Create a new data set
interp_set_t* newInterpSet() {

	interp_set_t* newSet = (interp_set_t*)malloc(sizeof(interp_set_t));
	assert( newSet!= NULL );

	newSet->pts = (interp_pt_t**)malloc(INTERP_INIT_ARRLEN*sizeof(interp_pt_t*));
	assert( newSet->pts != NULL);

	newSet->arrLen = INTERP_INIT_ARRLEN;
	newSet->N = 0;

	return newSet;
}

// Create a new point
interp_pt_t* newInterpPt(double x, double fx) {

	interp_pt_t* newPt = (interp_pt_t*)malloc(sizeof(interp_pt_t));
	assert(newPt != NULL);

	newPt->x = x;
	newPt->fx = fx;

	return newPt;
}

// Frees a set (including points)
void freeInterpSet(interp_set_t* set) {
	assert(set!=NULL);
	
	int i=0;
	for(i=0; i < set->N ; i++) {
		freeInterpPt(set->pts[i]);
	}
	free(set->pts);
	free(set);
}


void freeInterpPt(interp_pt_t* pt) {
	assert(pt!=NULL);
	free(pt);
}

void appendPtToSet(interp_set_t* set, interp_pt_t* pt) {

	assert(set!=NULL);
	assert(pt!=NULL);

	// extend array if necessary
	if( set->N >= set->arrLen) {
		set->arrLen += INTERP_INIT_ARRLEN;
		int newSize = set->arrLen * sizeof(interp_pt_t*);
		set->pts = (interp_pt_t**)realloc(set->pts, newSize );
	}

	// insert new pt
	set->pts[set->N] = pt;
	set->N++;
}

lagrange_term_t* newLagrangeTerm(interp_set_t* set, int index) {

	assert(set!=NULL);

	// initialise new lgrange_term_t
	lagrange_term_t* newTerm = (lagrange_term_t*)malloc(sizeof(lagrange_term_t));
	assert(newTerm != NULL);

	newTerm->order = set->N-1;
	newTerm->index = index;
	newTerm->fx_i = (set->pts[index])->fx;

	newTerm->root = (double*)calloc(newTerm->order+1, sizeof(double));
	assert(newTerm->root!=NULL);

	// calculate denominator
	newTerm->denominator = 1;
	interp_pt_t** pts = set->pts;
	int i=0;
	for(i=0; i <= newTerm->order ; i++) {
		if (i == index) { continue; }
		newTerm->denominator *= ((pts[index])->x - (pts[i])->x);
	}

	// calculate roots
	for(i=0; i <= newTerm->order ; i++) {
		if (i == index) { continue; }
		newTerm->root[i] = (pts[i])->x;
	}

	return newTerm;
}

lagrange_eqn_t* newLagrangeEqn(interp_set_t* set) {

	assert(set!=NULL);

	// initialise new lagrange_eqn_t
	lagrange_eqn_t* newEqn = (lagrange_eqn_t*)malloc(sizeof(lagrange_eqn_t));
	assert(newEqn != NULL);

	newEqn->num_terms = set->N;

	int arrSize = newEqn->num_terms * sizeof(lagrange_term_t*);
	newEqn->terms = (lagrange_term_t**)malloc(arrSize);
	assert(newEqn->terms != NULL);

	// generate terms
	int i=0;
	for (i=0; i < newEqn->num_terms ; i++) {
		newEqn->terms[i] = newLagrangeTerm(set, i);
	}

	return newEqn;
}

void freeLagrangeEqn(lagrange_eqn_t* eqn) {
	
	assert(eqn!=NULL);

	// generate terms
	int i=0;
	for (i=0; i < eqn->num_terms ; i++) {
		freeLagrangeTerm(eqn->terms[i]);
	}

	free(eqn->terms);
	free(eqn);
}

void freeLagrangeTerm(lagrange_term_t* term) {
	
	assert(term!=NULL);
	free(term->root);
	free(term);
}

interp_pt_t* evaluateLagrangeEqn(lagrange_eqn_t* eqn, double x) {

	assert(eqn!=NULL);

	double fx = 0;

	int i=0;
	for(i=0; i < eqn->num_terms ; i++) {
		fx += evaluateLagrangeTerm(eqn->terms[i],x);
	}

	return newInterpPt(x, fx);
}

double evaluateLagrangeTerm(lagrange_term_t* term, double x) {

	assert(term!=NULL);
	
	double numerator = term->fx_i;

	int i=0;
	for(i=0; i <= term->order; i++) {
		if(i == term->index) { continue; }
		numerator *= (x - term->root[i]);
	}

	return numerator/term->denominator;
}

cub_spline_t* newCubSpline(interp_set_t* set) {

	assert(set!=NULL);

	cub_spline_t* spline = (cub_spline_t*)malloc(sizeof(cub_spline_t));
	assert(spline!=NULL);

	int segsSize = (set->N)*sizeof(cub_spline_seg_t*);
	spline->segs = (cub_spline_seg_t**)malloc(segsSize);
	assert(spline->segs != NULL);

	spline->num_segs = set->N-1;

	int i=0;
	for(i=0; i < set->N; i++) {
		spline->segs[i] = newEmptyCubSplineSegment(i, (set->pts[i])->x);
	}

	assert(CUB_SPLINE_COMPUTE_SUCCESS == computeCubSplineConstants(set, spline));

	return spline;
}

cub_spline_seg_t* newEmptyCubSplineSegment(int index, double x_lo) {

	cub_spline_seg_t* seg = (cub_spline_seg_t*)malloc(sizeof(cub_spline_seg_t));
	assert(seg!=NULL);

	seg->index = index;
	seg->x_lo = x_lo;
	seg->a = 0;
	seg->b = 0;
	seg->c = 0;
	seg->d = 0;

	return seg;
}

void freeCubSpline(cub_spline_t* spline) {

	assert(spline!=NULL);

	int i=0;
	for (i=0; i<= spline->num_segs; i++) {
		freeCubSplineSegment(spline->segs[i]);
	}

	free(spline->segs);
	free(spline);
}

void freeCubSplineSegment(cub_spline_seg_t* seg) {
	assert(seg!=NULL);
	free(seg);
}

double splineH(int index, cub_spline_t* spline) {

	assert(spline!=NULL);
	assert(index < spline->num_segs);

	double x_lo = (spline->segs[index])->x_lo;
	double x_hi = (spline->segs[index+1])->x_lo;

	return x_hi - x_lo;
}

int computeCubSplineConstants(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	int successFlag = CUB_SPLINE_COMPUTE_SUCCESS;

	if( computeCubSplineAs(set, spline) == successFlag && 
		computeCubSplineCs(set, spline) == successFlag && 
		computeCubSplineBs(set, spline) == successFlag && 
		computeCubSplineDs(set, spline) == successFlag
	) {
		return successFlag;
	}
	
	return CUB_SPLINE_COMPUTE_FAIL;
}

int computeCubSplineAs(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	int i=0;
	for(i=0; i <=spline->num_segs; i++) {
		(spline->segs[i])->a = (set->pts[i])->fx;
	}

	return CUB_SPLINE_COMPUTE_SUCCESS;
}

int computeCubSplineBs(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	int i=0;
	double h_i, a_i, a_ip, c_i, c_ip;
	for(i=0; i <spline->num_segs; i++) {

		h_i = splineH(i,spline);
		a_i = (spline->segs[i])->a;
		a_ip = (spline->segs[i+1])->a;
		c_i = (spline->segs[i])->c;
		c_ip = (spline->segs[i+1])->c;

		if(TINY(h_i)) { return CUB_SPLINE_COMPUTE_FAIL; }

		(spline->segs[i])->b = CUB_SPLINE_B(h_i, a_i, a_ip, c_i, c_ip);
	}
	
	return CUB_SPLINE_COMPUTE_SUCCESS;
}

int computeCubSplineCs(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	// generate tridiag matrix
	tridiag_t *m = newTridiag();
	appendTridiagRow(m, 1.0, 0, 0, 0);
	
	int i=0;
	double h_im, h_i,  a_im, a_i, a_ip;
	double a, b, c, Q;
	for(i=1; i<spline->num_segs; i++) {
		h_im = splineH(i-1,spline);
		h_i = splineH(i,spline);
		a_im = (spline->segs[i-1])->a;
		a_i = (spline->segs[i])->a;
		a_ip = (spline->segs[i+1])->a;

		a = CUB_SPLINE_C_a(h_i, h_im);
		b = h_i;
		c = h_im;
		Q = CUB_SPLINE_C_RHS(h_im, h_i, a_im, a_i, a_ip);

		appendTridiagRow(m, a, b, c, Q);
	}
	appendTridiagRow(m, 1.0, 0, 0, 0);

	// solve tridiag
	if (solveTridiag(m) != SOLVER_SUCCESS) {
		freeTridiag(m);
		return CUB_SPLINE_COMPUTE_FAIL;
	}

	// load c's into spline
	for(i=0; i<=spline->num_segs; i++) {
		(spline->segs[i])->c = getTridiagRow(m, i+1)->x;
	}

	// free tridiag
	freeTridiag(m);

	return CUB_SPLINE_COMPUTE_SUCCESS;
}

int computeCubSplineDs(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	int i=0;
	double h_i, c_i, c_ip;
	for(i=0; i<spline->num_segs; i++) {

		h_i = splineH(i,spline);
		c_i = (spline->segs[i])->c;
		c_ip = (spline->segs[i+1])->c;

		if(TINY(h_i)) { return CUB_SPLINE_COMPUTE_FAIL; }

		(spline->segs[i])->d = CUB_SPLINE_D(h_i, c_i, c_ip);
	}

	return CUB_SPLINE_COMPUTE_SUCCESS;
}

interp_pt_t* evaluateCubSpline(cub_spline_t* spline, double x) {

	assert(spline!=NULL);

	double x_lo = (spline->segs[0])->x_lo;
	double x_hi = (spline->segs[spline->num_segs])->x_lo;
	assert(x>=x_lo && x<=x_hi);

	int i=0;
	while(x>=x_lo) {
		i++;
		x_lo = (spline->segs[i])->x_lo;
	}

	return evaluateCubSplineSegment(spline->segs[i-1], x);
}

interp_pt_t* evaluateCubSplineSegment(cub_spline_seg_t* seg, double x) {
	
	assert(seg!=NULL);
	double fx = EVAL_CUB_SPLINE(seg->a, seg->b, seg->c, seg->d, seg->x_lo, x);
	return newInterpPt(x, fx);
}

============================================
src/thomas_alg.h
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : thomas_alg.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <math.h>

#ifndef THOMAS_ALG_H
#define THOMAS_ALG_H

#define COMPUTE_A_S_START 1
#define COMPUTE_Q_S_START 1
#define COMPUTE_x_END 1

#define THOMAS_INIT_ARR_LEN 20
#define TINY(x) fabs(x) < 1e-11
#define SOLVER_FAIL -1
#define SOLVER_SUCCESS 1

typedef struct tridiag_row_struct {

    double a;
    double b;
    double c;
    double Q;
    double a_s;
    double Q_s;
    double x;

} tridiag_row_t;

typedef struct tridiag_struct {

    tridiag_row_t *rows;
    int N;
    int arrLen;

} tridiag_t;

tridiag_t *newTridiag();
void freeTridiag(tridiag_t *m);
void appendTridiagRow(tridiag_t *m, double a, double b, double c, double Q);
tridiag_row_t *getTridiagRow(tridiag_t *m, int i); //retrieve the ith row
int solveTridiag(tridiag_t *m);

int computeTridiag_a_s(tridiag_t *m);
int computeTridiag_Q_s(tridiag_t *m);
int computeTrigiag_x(tridiag_t *m);

#endif============================================
src/newton_raphson.h
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : newton_raphson.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifndef NEWTON_RAPHSON_H
#define NEWTON_RAPHSON_H

#define MAX_ITERATIONS 10
#define EPS 1e-9
#define DX EPS/100
#define ROOTFIND_FAIL -1

int newtonRaphson(double* xi, double* params, double (*f)(double, double*));
double dfdx(double x, double* params, double (*f)(double, double*));

#endif============================================
src/heat_sim.c
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : heat_sim.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "heat_sim.h"

heat_sim_t* newUnsolvedHeatSim(
	int Nx, 
	int Nt, 
	double x_lo, 
	double x_hi,
	double t_lo,
	double t_hi,
	double mu, 
	double (*init)(double x) 
) {

	assert(init!=NULL);

	heat_sim_t* sim = (heat_sim_t*)malloc(sizeof(heat_sim_t));
	assert(sim!=NULL);

	sim->mu = mu;
	sim->Nx = Nx;
	sim->Nt = Nt;
	sim->x_lo = x_lo;
	sim->x_hi = x_hi;
	sim->t_lo = t_lo;
	sim->t_hi = t_hi;

	sim->cells = (sim_cell_t**)calloc( sim->Nx+1, sizeof(sim_cell_t*));
	assert(sim->cells!=NULL);
	
	int i=0, j=0;
	double x_i=0, t_j=0;
	double dx = (x_hi-x_lo)/Nx;
	double dt = (t_hi-t_lo)/Nt;

	for(i=0; i<=sim->Nx; i++) {
		sim->cells[i] = (sim_cell_t*)calloc( sim->Nt+1, sizeof(sim_cell_t));
		assert(sim->cells[i]!=NULL);

		x_i = x_lo + i*dx;
		(sim->cells[i][0]).f = init(x_i);

		for(j=1; j<=sim->Nt; j++) {

			t_j = t_lo + j*dt;
			(sim->cells[i][j]).x = x_i;
			(sim->cells[i][j]).t = t_j;

		}
	}

	return sim;
}

void freeHeatSim(heat_sim_t* sim) {

	assert(sim!=NULL);
	
	int i=0;
	for(i=0; i<=sim->Nx; i++) {
		free(sim->cells[i]);
	}
	free(sim->cells);
	free(sim);
}

void eulerExFe(heat_sim_t* sim) {

	assert(sim!=NULL);

	// let i be x index, j is t index
	int j=0,i=0;
	double dx = (sim->x_hi-sim->x_lo)/sim->Nx;
	double dt = (sim->t_hi-sim->t_lo)/sim->Nt;
	double rhs;
	sim_cell_t** m = sim->cells; // cell matrix

	for(j=0; j<sim->Nt; j++) { // each timestep
		for(i=0; i<=sim->Nx; i++) { // each x value

			// get RHS (fixed end points)
			if(i==0 || i == sim->Nx) {
				rhs = 0.0;
			} else {
				rhs = EXPLICIT_RHS(sim->mu,dx, m[i-1][j].f, m[i][j].f, m[i+1][j].f);
			}

			// use RHS for explicit euler calculation
			m[i][j+1].f = m[i][j].f + dt * rhs;
		}
	}
}

void eulerExVe(heat_sim_t* sim) {

	assert(sim!=NULL);

	// let i be x index, j is t index
	int j=0,i=0;
	double dx = (sim->x_hi-sim->x_lo)/sim->Nx;
	double dt = (sim->t_hi-sim->t_lo)/sim->Nt;
	double rhs;
	sim_cell_t** m = sim->cells; // cell matrix

	for(j=0; j<sim->Nt; j++) { // each timestep
		for(i=0; i<=sim->Nx; i++) { // each x value

			// get RHS (fixed end points)
			if(i==0) {
				rhs = EXPLICIT_RHS(sim->mu,dx, m[i][j].f, m[i+1][j].f, m[i+2][j].f);
			} else if(i == sim->Nx) {
				rhs = EXPLICIT_RHS(sim->mu,dx, m[i-2][j].f, m[i-1][j].f, m[i][j].f);
			} else {
				rhs = EXPLICIT_RHS(sim->mu,dx, m[i-1][j].f, m[i][j].f, m[i+1][j].f);
			}

			// use RHS for explicit euler calculation
			m[i][j+1].f = m[i][j].f + dt * rhs;
		}
	}
}

void eulerImFe(heat_sim_t* sim) {

	assert(sim!=NULL);

	// let i be x index, j is t index
	int j=0,i=0;

	double dx = (sim->x_hi-sim->x_lo)/sim->Nx;
	double dt = (sim->t_hi-sim->t_lo)/sim->Nt;
	double d = (sim->mu * dt)/(dx*dx);

	sim_cell_t** m = sim->cells; // cell matrix
	tridiag_t* tri;

	for(j=1; j<=sim->Nt; j++) { // each timestep

		tri = newTridiag();

		// add rows to tridiagonal matrix
		appendTridiagRow(tri, 1, 0, 0, 0);
		for(i=1; i<sim->Nx; i++) {
			appendTridiagRow(tri, 2*d+1, -d, -d, m[i][j-1].f);
		}
		appendTridiagRow(tri, 1, 0, 0, 0);

		assert(solveTridiag(tri) == SOLVER_SUCCESS);

		for(i=0; i<=sim->Nx; i++) {
			tridiag_row_t *r = getTridiagRow(tri, i+1);
			m[i][j].f = r->x;
		}

		freeTridiag(tri);
	}
}============================================
src/main.c
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : main.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/time.h>
#include <string.h>
#include "tasks.h"

#define NUM_ARGS 6
#define INPUT_INSTRUCTIONS "Usage example: ./exec in_shock.csv in_linalsys.csv in_interp.csv 5 in_heateqn.csv"
#define ARGV_shockwave 1
#define ARGV_linalgbsys 2
#define ARGV_interp 3
#define ARGV_xo 4
#define ARGV_heateqn 5
#define MS_PER_SEC 1000.0

typedef struct timeval myTime_t;
myTime_t timer_start();
double timer_stop(myTime_t start);

int main(int argc, char *argv[]) {
	
	// Parse command line arguments
	char* shockwave_file_name = NULL;
	char* linalgbsys_file_name = NULL;
	char* interp_file_name = NULL;
	double xo = 0;
	char* heateqn_file_name = NULL;

	if(argc != NUM_ARGS) {
		printf(INPUT_INSTRUCTIONS);
		exit(EXIT_FAILURE);
	}

	shockwave_file_name = argv[ARGV_shockwave];
	linalgbsys_file_name = argv[ARGV_linalgbsys];
	interp_file_name = argv[ARGV_interp];
	xo = atof(argv[ARGV_xo]);
	heateqn_file_name = argv[ARGV_heateqn];
	//printf("shockwave %s, linalgbsys %s, interp %s, xo %f, heateqn %s\n", shockwave_file_name, linalgbsys_file_name, interp_file_name, xo, heateqn_file_name);

	/* Question 2 */
	myTime_t shockwave_time = timer_start();
	shockwave(shockwave_file_name);
	printf("shockwave: %.2lf milliseconds\n", timer_stop(shockwave_time));
	
	/* Question 4 */
	myTime_t linalgbsys_time = timer_start();
	linalgbsys(linalgbsys_file_name);
	printf("linalgbsys: %.2lf milliseconds\n", timer_stop(linalgbsys_time));
	
	/* Question 5 */
	myTime_t interp_time = timer_start();
	interp(interp_file_name, xo);
	printf("interp: %.2lf milliseconds\n", timer_stop(interp_time));
	
	/* Question 6 */
	myTime_t heateqn_time = timer_start();
	heateqn(heateqn_file_name);
	printf("heateqn: %.2lf milliseconds\n", timer_stop(heateqn_time));
    
	return EXIT_SUCCESS;
}

myTime_t timer_start() {
	myTime_t start;
	gettimeofday(&start, NULL);
	return start;
}

double timer_stop(myTime_t start) {
	myTime_t stop;
	gettimeofday(&stop, NULL);
	double elapsed_ms = (stop.tv_sec - start.tv_sec) * MS_PER_SEC;
	elapsed_ms += (stop.tv_usec - start.tv_usec) / MS_PER_SEC;
	return elapsed_ms;
}
============================================
src/tasks.h
03:41:25_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : tasks.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#include "newton_raphson.h"
#include "thomas_alg.h"
#include "interpolate.h"
#include "heat_sim.h"

#ifndef TASKS_H

#define FILE_READONLY "r"
#define FILE_OVERWRITE "w"

#define PI 3.14159265359
#define DEG2RAD(deg) deg * PI / 180.0
#define RAD2DEG(rad) rad * 180.0 / PI

#define NUM_PARAMS_2 5
#define F_M_2 0
#define F_T_2 1
#define F_G_2 2
#define F_2(b,M,t,g) (2.0/tan(b)) * (pow(M*sin(b), 2.0) - 1.0) / (M*M*(g + cos(2.0*b)) + 2.0) - tan(t)
#define B_l_GUESS_2 20.0
#define B_u_GUESS_2 90.0
#define IN_1ST_HEADER_2 "M,theta,beta_l,beta_u,gamma\n"
#define IN_2ND_HEADER_2 "M\n"
#define FILENAME_2B "my_2b.csv"
#define FILENAME_2C "out_shock.csv"
#define FILE_HEADER_2BC "M,theta,beta_lower,beta_upper\n"
#define RADIAN_START_2B 0
#define RADIAN_INCREMENT_2B DEG2RAD(1)
#define M_LEN_2C 20

#define NUM_PARAMS_3 4
#define FILENAME_3 "out_linalsys.csv"
#define FILE_HEADER_3 "x\n"
#define IN_HEADER_3 "a,b,c,q\n"

#define NUM_PARAMS_5 2
#define IN_HEADER_5 "x,f(x)\n"
#define PLOT_FILENAME_ANY_ORDER_5 "my_any_order_5.csv"
#define PLOT_FILENAME_QUADRATIC_5 "my_quadratic_5.csv"
#define FILENAME_5 "out_interp.csv"
#define PLOT_START_5 0
#define PLOT_END_5 8
#define PLOT_INTERVAL_5 0.01
#define PLOT_HEADER_LAGRANGE_5 "x,lagrange,spline\n"
#define HEADER_LAGRANGE_5 "lagrange\n"
#define HEADER_CUBIC_5 "cubic\n"

#define NUM_PARAMS_6 3
#define X_LO_6 0.0
#define X_HI_6 1.0
#define T_LO_6 0.0
#define T_HI_6 2.0
#define IC_LO_6 0.125
#define IC_6(x) 0.5*(1.0-cos(8.0*PI*(x - 0.125)))
#define IC_HI_6 0.375
#define IN_HEADER_6 "mu,Nx,Nt\n"
#define OUT_HEADER_6 "x,f(x)\n"
#define FILENAME_EX_FE_6 "out_heateqn_explicit_fe.csv"
#define FILENAME_EX_VE_6 "out_heateqn_explicit_ve.csv"
#define FILENAME_IM_FE_6 "out_heateqn_implicit_fe.csv"

// Input type for shockwave question (Question 2)
typedef struct input_2 {

	double M_a;
	double t_a;
	double g_a;
	double b_l_a;
	double b_u_a;
	double *M_c;
	int num_M_c;

} input_2_t;

/* * * * * * * * * * * * * * * * * * * * * * * * * *  HEATEQN HELPER FUNCTIONS */

heat_sim_t* parseInput_6(const char* filename);
double myInitialCondition_6(double x);
void printSim_6(heat_sim_t* sim, const char* filename);


/* * * * * * * * * * * * * * * * * * * * * * * * * *  INTERP HELPER FUNCTIONS */

interp_set_t* parseInput_5(const char* filename);
interp_pt_t* evaluateQuadLagrangeEqn(interp_set_t* set, double xo);
void printInterp_5(double lag, double spline);
void plotInterpAnyOrder_5(lagrange_eqn_t* lagEqn, cub_spline_t* splineEqn);
void plotInterpQuadratic_5(interp_set_t* set, cub_spline_t* splineEqn);


/* * * * * * * * * * * * * * * * * * * * * * * * LINALGBYSYS HELPER FUNCTIONS */

tridiag_t *parseInput_3(const char* filename);
void printTridiag_3(tridiag_t *m);


/* * * * * * * * * * * * * * * * * * * * * * * * * SHOCKWAVE HELPER FUNCTIONS */

input_2_t *parseInput_2(const char* filename);
void parseInput2ndLine_2(FILE* fp, input_2_t* parsed);
void parseInputMvals_2(FILE* fp, input_2_t* parsed);
void freeInput_2(input_2_t *parsed);
double f_2(double beta, double* params);
void shockwave_2a(const input_2_t *parsed);
void shockwave_2b(const input_2_t *parsed);
void shockwave_2c(const input_2_t *parsed);


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * TASK FUNCTIONS */

void shockwave(const char* q2_file);
void linalgbsys(const char* q4_file);
void interp(const char* q5_file, const double xo);
void heateqn(const char* q6_file);

#endif
