============================================
vis/output.txt
05:25:52_Monday_16_October_2017
============================================

Compiling with gcc -Wall -std=c99 ... 
Compilation succeeded.
setrlimit failed.
Compilation succeeded.
setrlimit failed.
==12243== Memcheck, a memory error detector
==12243== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
==12243== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info
==12243== Command: exec ../data/in_shock.csv ../data/in_linalsys.csv ../data/in_interp.csv 5 ../data/in_heateqn.csv
==12243== 
==12249== Memcheck, a memory error detector
==12249== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
==12249== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info
==12249== Command: exec ../data/in_shock.csv ../data/in_linalsys.csv ../data/in_interp.csv 5 ../data/in_heateqn.csv
==12249== 
shockwave: 321.14 milliseconds
linalgbsys: 12.97 milliseconds
interp: 290.00 milliseconds
heateqn: 117.23 milliseconds
==12243== 
==12243== HEAP SUMMARY:
==12243==     in use at exit: 1,704 bytes in 3 blocks
==12243==   total heap usage: 16,084 allocs, 16,081 frees, 9,661,816 bytes allocated
==12243== 
==12243== LEAK SUMMARY:
==12243==    definitely lost: 0 bytes in 0 blocks
==12243==    indirectly lost: 0 bytes in 0 blocks
==12243==      possibly lost: 0 bytes in 0 blocks
==12243==    still reachable: 1,704 bytes in 3 blocks
==12243==         suppressed: 0 bytes in 0 blocks
==12243== Rerun with --leak-check=full to see details of leaked memory
==12243== 
==12243== For counts of detected and suppressed errors, rerun with: -v
==12243== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 6 from 6)
============================================
Test for input file: 
Files ../data/out_shock.csv and out_shock.csv differ
 
Oops, your shock solution seems to be INCORRECT.  :(
 
 
Your algebraic systems seems to be CORRECT.  :)
 
shockwave: 337.13 milliseconds
linalgbsys: 12.96 milliseconds
interp: 293.61 milliseconds
heateqn: 119.92 milliseconds
 
Your interpolation seems to be CORRECT.  :)
 
 
Your heat eqn explicit fixed ends seems to be CORRECT.  :)
 
 
Your heat eqn explicit variable ends seems to be CORRECT.  :)
 
 
Your heat eqn implicit fixed ends seems to be CORRECT.  :)
 
==12249== 
==12249== HEAP SUMMARY:
==12249==     in use at exit: 1,704 bytes in 3 blocks
==12249==   total heap usage: 16,084 allocs, 16,081 frees, 9,661,816 bytes allocated
==12249== 
==12249== LEAK SUMMARY:
==12249==    definitely lost: 0 bytes in 0 blocks
==12249==    indirectly lost: 0 bytes in 0 blocks
==12249==      possibly lost: 0 bytes in 0 blocks
==12249==    still reachable: 1,704 bytes in 3 blocks
==12249==         suppressed: 0 bytes in 0 blocks
==12249== Rerun with --leak-check=full to see details of leaked memory
==12249== 
==12249== For counts of detected and suppressed errors, rerun with: -v
==12249== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 6 from 6)
============================================
Test for input file: 
============================================
vis/sebastianb1-output.txt
05:25:52_Monday_16_October_2017
============================================
======================================================
                    SHOCK WAVE                        
======================================================
======================================================
                 LINEAR ALG SYSTEMS                   
======================================================
======================================================
                  INTERPOLATION                       
======================================================
======================================================
           HEAT EQN EXPLICIT FIXED ENDS               
======================================================
======================================================
          HEAT EQN EXPLICIT VARIABLE ENDS             
======================================================
======================================================
          HEAT EQN IMPLICIT FIXED ENDS             
======================================================
======================================================
============================================
src/main.c
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : main.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/time.h>
#include <string.h>
#include "tasks.h"

#define NUM_ARGS 6
#define INPUT_INSTRUCTIONS "Usage example: ./exec in_shock.csv in_linalsys.csv in_interp.csv 5 in_heateqn.csv"
#define ARGV_shockwave 1
#define ARGV_linalgbsys 2
#define ARGV_interp 3
#define ARGV_xo 4
#define ARGV_heateqn 5
#define MS_PER_SEC 1000.0

typedef struct timeval myTime_t;
myTime_t timer_start();
double timer_stop(myTime_t start);

int main(int argc, char *argv[]) {
	
	// Parse command line arguments
	char* shockwave_file_name = NULL;
	char* linalgbsys_file_name = NULL;
	char* interp_file_name = NULL;
	double xo = 0;
	char* heateqn_file_name = NULL;

	if(argc != NUM_ARGS) {
		printf(INPUT_INSTRUCTIONS);
		exit(EXIT_FAILURE);
	}

	shockwave_file_name = argv[ARGV_shockwave];
	linalgbsys_file_name = argv[ARGV_linalgbsys];
	interp_file_name = argv[ARGV_interp];
	xo = atof(argv[ARGV_xo]);
	heateqn_file_name = argv[ARGV_heateqn];

	/* Question 2 */
	myTime_t shockwave_time = timer_start();
	shockwave(shockwave_file_name);
	printf("shockwave: %.2lf milliseconds\n", timer_stop(shockwave_time));
	
	/* Question 3 */
	myTime_t linalgbsys_time = timer_start();
	linalgbsys(linalgbsys_file_name);
	printf("linalgbsys: %.2lf milliseconds\n", timer_stop(linalgbsys_time));
	
	/* Question 5 */
	myTime_t interp_time = timer_start();
	interp(interp_file_name, xo);
	printf("interp: %.2lf milliseconds\n", timer_stop(interp_time));
	
	/* Question 6 */
	myTime_t heateqn_time = timer_start();
	heateqn(heateqn_file_name);
	printf("heateqn: %.2lf milliseconds\n", timer_stop(heateqn_time));
    
	return EXIT_SUCCESS;
}

myTime_t timer_start() {
	myTime_t start;
	gettimeofday(&start, NULL);
	return start;
}

double timer_stop(myTime_t start) {
	myTime_t stop;
	gettimeofday(&stop, NULL);
	double elapsed_ms = (stop.tv_sec - start.tv_sec) * MS_PER_SEC;
	elapsed_ms += (stop.tv_usec - start.tv_usec) / MS_PER_SEC;
	return elapsed_ms;
}
============================================
src/interpolate.h
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : interpolate.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "thomas_alg.h"

#ifndef INTERPOLATE_H

#define INTERP_INIT_ARRLEN 20
#define QUADRATIC_NUM_PTS 3
#define CUB_SPLINE_COMPUTE_SUCCESS 1
#define CUB_SPLINE_COMPUTE_FAIL -1
#define TINY(x) fabs(x) < 1e-11
#define CUB_SPLINE_B(h_1, a_1, a_2, c_1, c_2) (a_2-a_1)/h_1 - h_1*(2.0*c_1+c_2)/3.0
#define CUB_SPLINE_C_RHS(h_0, h_1, a_0, a_1, a_2) 3.0*(a_2-a_1)/h_1 + 3.0*(a_0-a_1)/h_0
#define CUB_SPLINE_C_a(h_1, h_0) 2.0*(h_1+h_0)
#define CUB_SPLINE_D(h_1, c_1, c_2) (c_2-c_1)/(3.0*h_1)
#define EVAL_CUB_SPLINE(a,b,c,d,x_i,x) a + b*(x-x_i) + c*pow(x-x_i,2) + d*pow(x-x_i,3)

// simple struct to hold an x,fx tuple
typedef struct interp_pt {

	double x;
	double fx;

} interp_pt_t;

// dynamic array to hold a set of points to interpolate
typedef struct interp_set {

	interp_pt_t** pts;
	int N;
	int arrLen;

} interp_set_t;

// represents a lagrange term
typedef struct lagrange_term {

	int index;
	int order;
	double* root;
	double fx_i;
	double denominator;

} lagrange_term_t;

// represents a lagrange equation
typedef struct lagrange_eqn {

	lagrange_term_t** terms;
	int num_terms;

} lagrange_eqn_t;

// represents a cubic spline segment
typedef struct cub_spline_segment {

	int index;
	double x_lo;
	double a;
	double b;
	double c;
	double d;

} cub_spline_seg_t;

// represents a cubic spline
typedef struct cub_spline {

	cub_spline_seg_t** segs;
	int num_segs; // not including the unused/incomplete end segment eg: 4 points means 3 segments

} cub_spline_t;

// manage set dynamic array
interp_set_t* newInterpSet();
interp_pt_t* newInterpPt(double x, double fx);
void freeInterpSet(interp_set_t* set);
void freeInterpPt(interp_pt_t* pt);
void appendPtToSet(interp_set_t* set, interp_pt_t* pt);

// create, evaluate lagrange equations
lagrange_term_t* newLagrangeTerm(interp_set_t* set, int index);
lagrange_eqn_t* newLagrangeEqn(interp_set_t* set);
void freeLagrangeEqn(lagrange_eqn_t* eqn);
void freeLagrangeTerm(lagrange_term_t* term);
interp_pt_t* evaluateLagrangeEqn(lagrange_eqn_t* eqn, double x);
double evaluateLagrangeTerm(lagrange_term_t* term, double x);

// create, evaluate cubic splines
cub_spline_t* newCubSpline(interp_set_t* set);
cub_spline_seg_t* newEmptyCubSplineSegment(int index, double x_lo);
void freeCubSpline(cub_spline_t* spline);
void freeCubSplineSegment(cub_spline_seg_t* seg);
double splineH(int index, cub_spline_t* spline);
int computeCubSplineConstants(interp_set_t* set, cub_spline_t* spline);
int computeCubSplineAs(interp_set_t* set, cub_spline_t* spline);
int computeCubSplineBs(interp_set_t* set, cub_spline_t* spline);
int computeCubSplineCs(interp_set_t* set, cub_spline_t* spline);
int computeCubSplineDs(interp_set_t* set, cub_spline_t* spline);
interp_pt_t* evaluateCubSpline(cub_spline_t* spline, double x);
interp_pt_t* evaluateCubSplineSegment(cub_spline_seg_t* seg, double x);

#endif============================================
src/heat_sim.c
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : heat_sim.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "heat_sim.h"

// creates a new unsolved heat simulation struct
heat_sim_t* newUnsolvedHeatSim(
	int Nx, 
	int Nt, 
	double x_lo, 
	double x_hi,
	double t_lo,
	double t_hi,
	double mu, 
	double (*init)(double x) 
) {

	assert(init!=NULL);

	heat_sim_t* sim = (heat_sim_t*)malloc(sizeof(heat_sim_t));
	assert(sim!=NULL);

	sim->mu = mu;
	sim->Nx = Nx;
	sim->Nt = Nt;
	sim->x_lo = x_lo;
	sim->x_hi = x_hi;
	sim->t_lo = t_lo;
	sim->t_hi = t_hi;

	sim->cells = (sim_cell_t**)calloc( sim->Nx+1, sizeof(sim_cell_t*));
	assert(sim->cells!=NULL);
	
	int i=0, j=0;
	double x_i=0, t_j=0;
	double dx = (x_hi-x_lo)/Nx;
	double dt = (t_hi-t_lo)/Nt;

	// initialise the matrix at t = 0
	for(i=0; i<=sim->Nx; i++) {
		sim->cells[i] = (sim_cell_t*)calloc( sim->Nt+1, sizeof(sim_cell_t));
		assert(sim->cells[i]!=NULL);

		x_i = x_lo + i*dx;
		(sim->cells[i][0]).f = init(x_i);

		for(j=1; j<=sim->Nt; j++) {

			t_j = t_lo + j*dt;
			(sim->cells[i][j]).x = x_i;
			(sim->cells[i][j]).t = t_j;
		}
	}
	return sim;
}

// free heat simulation struct
void freeHeatSim(heat_sim_t* sim) {

	assert(sim!=NULL);
	
	int i=0;
	for(i=0; i<=sim->Nx; i++) {
		free(sim->cells[i]);
	}
	free(sim->cells);
	free(sim);
}

// solve heat eqn simulation using explicit euler with fixed end points
void eulerExFe(heat_sim_t* sim) {

	assert(sim!=NULL);

	// let i be x index, j is t index
	int j=0,i=0;
	double dx = (sim->x_hi-sim->x_lo)/sim->Nx;
	double dt = (sim->t_hi-sim->t_lo)/sim->Nt;
	double mu = sim->mu;
	double rhs;
	sim_cell_t** m = sim->cells; // cell matrix

	for(j=0; j<sim->Nt; j++) { // each timestep
		for(i=0; i<=sim->Nx; i++) { // each x value

			// get RHS (fixed end points)
			if(i==0 || i == sim->Nx) {
				rhs = 0.0;
			} else {
				rhs = EXPLICIT_RHS(mu,dx, m[i-1][j].f, m[i][j].f, m[i+1][j].f);
			}

			// use RHS for explicit euler calculation
			m[i][j+1].f = m[i][j].f + dt * rhs;
		}
	}
}

// solve heat eqn simulation using explicit euler with variable end points
void eulerExVe(heat_sim_t* sim) {

	assert(sim!=NULL);

	// let i be x index, j is t index
	int j=0,i=0;
	double dx = (sim->x_hi-sim->x_lo)/sim->Nx;
	double dt = (sim->t_hi-sim->t_lo)/sim->Nt;
	double rhs;
	sim_cell_t** m = sim->cells; // cell matrix

	for(j=0; j<sim->Nt; j++) { // each timestep
		for(i=0; i<=sim->Nx; i++) { // each x value

			// get RHS (fixed end points)
			if(i==0) {
				rhs = EXPLICIT_RHS(sim->mu,dx, m[i][j].f, m[i+1][j].f, m[i+2][j].f);
			} else if(i == sim->Nx) {
				rhs = EXPLICIT_RHS(sim->mu,dx, m[i-2][j].f, m[i-1][j].f, m[i][j].f);
			} else {
				rhs = EXPLICIT_RHS(sim->mu,dx, m[i-1][j].f, m[i][j].f, m[i+1][j].f);
			}

			// use RHS for explicit euler calculation
			m[i][j+1].f = m[i][j].f + dt * rhs;
		}
	}
}

// solve heat eqn simulation using implicit euler with fixed end points
void eulerImFe(heat_sim_t* sim) {

	assert(sim!=NULL);

	// let i be x index, j is t index
	int j=0,i=0;

	double dx = (sim->x_hi-sim->x_lo)/sim->Nx;
	double dt = (sim->t_hi-sim->t_lo)/sim->Nt;
	double d = (sim->mu * dt)/(dx*dx);

	sim_cell_t** m = sim->cells; // cell matrix
	tridiag_t* tri;

	for(j=1; j<=sim->Nt; j++) { // each timestep

		tri = newTridiag();

		// add rows to tridiagonal matrix
		appendTridiagRow(tri, 1, 0, 0, 0);
		for(i=1; i<sim->Nx; i++) {
			appendTridiagRow(tri, 2*d+1, -d, -d, m[i][j-1].f);
		}
		appendTridiagRow(tri, 1, 0, 0, 0);

		assert(solveTridiag(tri) == SOLVER_SUCCESS);

		for(i=0; i<=sim->Nx; i++) {
			tridiag_row_t *r = getTridiagRow(tri, i+1);
			m[i][j].f = r->x;
		}

		freeTridiag(tri);
	}
}============================================
src/tasks.c
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : tasks.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "tasks.h"

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * TASK FUNCTIONS */

void shockwave(const char* filename) {

	input_2_t *parsed = parseInput_2(filename);
	shockwave_2a(parsed);
	shockwave_2b(parsed);
	shockwave_2c(parsed);
	freeInput_2(parsed);
}

void linalgbsys(const char* filename) {

	tridiag_t *m = parseInput_3(filename);
	assert(solveTridiag(m) == SOLVER_SUCCESS);
	printTridiag_3(m);
	freeTridiag(m);
}

void interp(const char* filename, const double xo) {
	
	interp_set_t* set = parseInput_5(filename);
	cub_spline_t* spline = newCubSpline(set);
	lagrange_eqn_t* lagEqn = newLagrangeEqn(set);

	// generates data for plots
	plotInterpAnyOrder_5(lagEqn, spline);
	plotInterpQuadratic_5(set, spline);

	// calculate/output the interpolated values at xo
	interp_pt_t* lagEval = evaluateQuadLagrangeEqn(set, xo);
	interp_pt_t* splineEval = evaluateCubSpline(spline, xo);
	printInterp_5(lagEval->fx, splineEval->fx);
	freeInterpPt(lagEval);
	freeInterpPt(splineEval);

	freeLagrangeEqn(lagEqn);
	freeCubSpline(spline);
	freeInterpSet(set);
}

void heateqn(const char* filename) {

	heat_sim_t* exFe = parseInput_6(filename);
	eulerExFe(exFe);
	printSim_6(exFe, FILENAME_EX_FE_6);
	freeHeatSim(exFe);

	heat_sim_t* exVe = parseInput_6(filename);
	eulerExVe(exVe);
	printSim_6(exVe, FILENAME_EX_VE_6);
	freeHeatSim(exVe);

	heat_sim_t* imFe = parseInput_6(filename);
	eulerImFe(imFe);
	printSim_6(imFe, FILENAME_IM_FE_6);
	freeHeatSim(imFe);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * HEATEQN HELPER FUNCTIONS */

// parses heat simulation file and returns a new unsolved heat simulation
heat_sim_t* parseInput_6(const char* filename) {

	assert(filename!=NULL);

	// open file
	FILE* fp = fopen(filename, FILE_READONLY);
	assert(fp != NULL);

	double mu;
	int Nx, Nt;

	fscanf(fp, IN_HEADER_6);
	assert(fscanf(fp,"%lf,%d,%d\n", &mu, &Nx, &Nt) == NUM_PARAMS_6);
	fclose(fp);
	
	return newUnsolvedHeatSim(
		Nx, Nt, X_LO_6, X_HI_6, T_LO_6, T_HI_6, mu, myInitialCondition_6 );
}

// initial condition for f(x,t=0)
double myInitialCondition_6(double x) {

	if(x>=IC_LO_6 && x<=IC_HI_6) {
		return IC_6(x);
	}
	return 0.0;
}

// print x's at 100th timestep
void printSim_6(heat_sim_t* sim, const char* filename) {
	
	assert(sim!=NULL);
	assert(filename!=NULL);

	sim_cell_t** m = sim->cells; // cell matrix

	FILE* fp = fopen(filename, FILE_OVERWRITE);
	assert(fp!=NULL);

	fprintf(fp, OUT_HEADER_6);

	int i=0;
	int j=100;
	for(i=0; i<=sim->Nx; i++) {
		fprintf(fp, "%.4f,%.4f\n", m[i][j].x, m[i][j].f);
    }
}


/* * * * * * * * * * * * * * * * * * * * * * * * * *  INTERP HELPER FUNCTIONS */

// parse input for interpolation task, return the set
interp_set_t* parseInput_5(const char* filename) {

	assert(filename!=NULL);

	interp_set_t* newSet = newInterpSet(); 

	// open file
	FILE* fp = fopen(filename, FILE_READONLY);
	assert(fp != NULL);

	double tmp_x, tmp_fx;
	fscanf(fp, IN_HEADER_5);
	int read = 0;
	int i=0;
	while(1) {
		read = fscanf(fp,"%lf,%lf\n", &tmp_x, &tmp_fx);
		if(read != NUM_PARAMS_5) { break; }
		appendPtToSet(newSet, newInterpPt(tmp_x, tmp_fx));
		i++;
	}

	fclose(fp);

	return newSet;
}

// generate a quadratic lagrange eqn from a set, evaluate it at xo
interp_pt_t* evaluateQuadLagrangeEqn(interp_set_t* set, double xo) {

	// require at least 3 points to make a quadratic
	assert(set->N >= QUADRATIC_NUM_PTS);

	// insert the 3 closest points to xo into a new set to make the quadratic
	// note that my implementation does not require points to be in any order
	interp_set_t* newSet = newInterpSet();
	interp_pt_t* p1 = set->pts[0];
	double p1_diff = DBL_MAX;
	interp_pt_t* p2 = set->pts[0];
	double p2_diff = DBL_MAX;
	interp_pt_t* p3 = set->pts[0];
	double p3_diff = DBL_MAX;

	// find 1st closest point
	int i = 0;
	for(i=0; i < set->N ; i++) {
		if(p1_diff >= fabs(set->pts[i]->x-xo)) {
			p1 = set->pts[i];
			p1_diff = fabs(p1->x-xo);
		}
	}
	appendPtToSet(newSet, newInterpPt(p1->x, p1->fx));

	// find 2nd closest point
	for(i=0; i < set->N ; i++) {
		if(
			p2_diff >= fabs(set->pts[i]->x-xo) &&
			set->pts[i] != p1
		) {
			p2 = set->pts[i];
			p2_diff = fabs(p2->x-xo);
		}
	}
	appendPtToSet(newSet, newInterpPt(p2->x, p2->fx));

	// find 3nd closest point
	for(i=0; i < set->N ; i++) {
		if(
			p3_diff >= fabs(set->pts[i]->x-xo) && 
			set->pts[i] != p1 &&
			set->pts[i] != p2
		) {
			p3 = set->pts[i];
			p3_diff = fabs(p3->x-xo);
		}
	}
	appendPtToSet(newSet, newInterpPt(p3->x, p3->fx));

	// generate & evaluate the equation
	lagrange_eqn_t* lagEqn = newLagrangeEqn(newSet);
	interp_pt_t* lagEval = evaluateLagrangeEqn(lagEqn, xo);
	freeLagrangeEqn(lagEqn);
	freeInterpSet(newSet);

	return lagEval;
}

// simple function to print the output for the interpolation output
void printInterp_5(double lag, double spline) {

	// open file
	FILE* fp = fopen(FILENAME_5, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp, HEADER_LAGRANGE_5);
	fprintf(fp, "%.4f\n", lag);
	fprintf(fp, HEADER_CUBIC_5);
	fprintf(fp, "%.4f\n", spline);

	fclose(fp);
}

// generates data comparing lagrange (any order), spline interpolations
void plotInterpAnyOrder_5(lagrange_eqn_t* lagEqn, cub_spline_t* spline) {

	// open file
	FILE* fp = fopen(PLOT_FILENAME_ANY_ORDER_5, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp, PLOT_HEADER_LAGRANGE_5);

	double x = PLOT_START_5;
	interp_pt_t* tmp_pt;
	while(x < PLOT_END_5) {

		fprintf(fp, "%.4f,", x);
		tmp_pt = evaluateLagrangeEqn(lagEqn, x);
		fprintf(fp, "%.4f,", tmp_pt->fx);
		freeInterpPt(tmp_pt);
		tmp_pt = evaluateCubSpline(spline, x);
		fprintf(fp, "%.4f\n", tmp_pt->fx);
		freeInterpPt(tmp_pt);
		x = x + PLOT_INTERVAL_5;
	}

	fclose(fp);
}

// generates data comparing lagrange (quadratic), spline interpolations
void plotInterpQuadratic_5(interp_set_t* set, cub_spline_t* spline) {

	// open file
	FILE* fp = fopen(PLOT_FILENAME_QUADRATIC_5, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp, PLOT_HEADER_LAGRANGE_5);

	double x = PLOT_START_5;
	interp_pt_t* tmp_pt;
	while(x < PLOT_END_5) {

		fprintf(fp, "%.4f,", x);
		tmp_pt = evaluateQuadLagrangeEqn(set, x);
		fprintf(fp, "%.4f,", tmp_pt->fx);
		freeInterpPt(tmp_pt);
		tmp_pt = evaluateCubSpline(spline, x);
		fprintf(fp, "%.4f\n", tmp_pt->fx);
		freeInterpPt(tmp_pt);
		x = x + PLOT_INTERVAL_5;
	}

	fclose(fp);
}


/* * * * * * * * * * * * * * * * * * * * * * * * LINALGBYSYS HELPER FUNCTIONS */

// parses input for task 3, returns a tridiagonal matrix equation
tridiag_t *parseInput_3(const char* filename) {
	
	assert(filename!=NULL);

	tridiag_t *m = newTridiag();

	// open file
	FILE* fp = fopen(filename, FILE_READONLY);
	assert(fp != NULL);

	double tmp_a, tmp_b, tmp_c, tmp_q;
	fscanf(fp, IN_HEADER_3);
	int read = 0;
	while(1) {
		read = fscanf(fp,"%lf,%lf,%lf,%lf\n", &tmp_a, &tmp_b, &tmp_c, &tmp_q);
		if(read != NUM_PARAMS_3) { break; }
		appendTridiagRow(m,tmp_a, tmp_b, tmp_c, tmp_q);
	}

	fclose(fp);
	return m;
}

// prints the solved tridiagonal linear system
void printTridiag_3(tridiag_t *m) {

	assert(m!=NULL);

	FILE* fp = fopen(FILENAME_3, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp, FILE_HEADER_3);
	int i=1;
	for(i=1; i <= m->N; i++) {
		tridiag_row_t *r = getTridiagRow(m, i);
		fprintf(fp,"%.4f\n",r->x);
	}

	fclose(fp);
}


/* * * * * * * * * * * * * * * * * * * * * * * * * SHOCKWAVE HELPER FUNCTIONS */

// parses input from task 2, puts it into a nice struct
input_2_t *parseInput_2(const char* filename) {
	
	assert(filename!=NULL);
	
	// allocate memory
	input_2_t *parsed = (input_2_t*)malloc(sizeof(input_2_t));
	assert(parsed != NULL);
	parsed->M_c = (double*)calloc(M_LEN_2C, sizeof(double));
	assert(parsed->M_c != NULL);

	// open file
	FILE* fp = fopen(filename, FILE_READONLY);
	assert(fp != NULL);

	// parse file
	parseInput2ndLine_2(fp, parsed);
	parseInputMvals_2(fp, parsed);

	fclose(fp);
	return parsed;
}

// parses the first part of the shockwave input file
void parseInput2ndLine_2(FILE* fp, input_2_t* parsed) {
	
	assert(parsed!=NULL && fp!= NULL);

	fscanf(fp, IN_1ST_HEADER_2);

	assert(NUM_PARAMS_2 == fscanf(
		fp,
		"%lf,%lf,%lf,%lf,%lf\n",
		&(parsed->M_a),
		&(parsed->t_a),
		&(parsed->b_l_a),
		&(parsed->b_u_a),
		&(parsed->g_a)
	) );
}

// parses the 2nd part of the shockwave input file
void parseInputMvals_2(FILE* fp, input_2_t* parsed) {
	
	assert(parsed!=NULL && fp!= NULL);

	fscanf(fp, IN_2ND_HEADER_2);

	int i=0;
	int arrayLength = M_LEN_2C;
	while( 1 == fscanf(fp,"%lf", &(parsed->M_c[i])) ) {

		// Extend array if necessary
		if(i >= arrayLength) {
			arrayLength += M_LEN_2C;
			parsed->M_c = (double*)realloc(parsed->M_c, arrayLength*sizeof(double));
			assert(parsed->M_c != NULL);
		}
		i++;
	}
	parsed->num_M_c = i;
}

// free's the input struct for shockwave qn
void freeInput_2(input_2_t *parsed) {
	assert(parsed!=NULL);
	free(parsed->M_c);
	free(parsed);
}

// returns the result of the shockwave function for a beta value
double f_2(double beta, double* params) {
	assert(params!=NULL);
	return F_2( beta, params[F_M_2], params[F_T_2], params[F_G_2]);
}

// shockwave part a
void shockwave_2a(const input_2_t *parsed) {

	assert(parsed!=NULL);

	double b_l = DEG2RAD(parsed->b_l_a);
	double b_u = DEG2RAD(parsed->b_u_a);
	double params[] = {
		parsed->M_a,
		DEG2RAD(parsed->t_a),
		parsed->g_a
	};

	int b_l_itr = newtonRaphson(&b_l, params, f_2);
	int b_u_itr = newtonRaphson(&b_u, params, f_2);
	assert( b_l_itr != ROOTFIND_FAIL && b_u_itr != ROOTFIND_FAIL);
	//printf("%f,%f\n", RAD2DEG(b_l), RAD2DEG(b_u));
}

// prints the shockwave roots for a range of thetas until failure
void shockwavePrintThetaRange_2bc(FILE* fp, double* params) {

	int b_u_itr=0, b_l_itr=0;
	double b_l = DEG2RAD(B_l_GUESS_2), b_u = DEG2RAD(B_u_GUESS_2);

	while(1) {
		b_l_itr = newtonRaphson(&b_l, params, f_2);
		b_u_itr = newtonRaphson(&b_u, params, f_2);
		if( b_l_itr == ROOTFIND_FAIL || b_u_itr == ROOTFIND_FAIL) { break; }
		
		fprintf(fp, "%.4f,%.0f,%.4f,%.4f\n",
			params[F_M_2],
			RAD2DEG(params[F_T_2]),
			RAD2DEG(b_l),
			RAD2DEG(b_u)
		);

		params[F_T_2] += RADIAN_INCREMENT_2B;
	}
}

// shockwave part b
void shockwave_2b(const input_2_t *parsed) {

	assert(parsed!=NULL);

	double params[] = { parsed->M_a, RADIAN_START_2B, parsed->g_a };

	FILE* fp = fopen(FILENAME_2B, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp,FILE_HEADER_2BC);
	shockwavePrintThetaRange_2bc( fp, params );

	fclose(fp);
}

// shockwave part c
void shockwave_2c(const input_2_t *parsed) {

	assert(parsed!=NULL);	

	FILE* fp = fopen(FILENAME_2C, FILE_OVERWRITE);
	assert(fp != NULL);

	fprintf(fp,FILE_HEADER_2BC);
	
	int i=0;
	for(i=0; i<parsed->num_M_c; i++) {
		double params[] = { parsed->M_c[i], RADIAN_START_2B, parsed->g_a };
		shockwavePrintThetaRange_2bc( fp, params);
	}

	fclose(fp);
}
============================================
src/newton_raphson.h
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : newton_raphson.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifndef NEWTON_RAPHSON_H
#define NEWTON_RAPHSON_H

#define MAX_ITERATIONS 40
#define EPS 1e-9
#define DX EPS/1000
#define ROOTFIND_FAIL -1

int newtonRaphson(double* xi, double* params, double (*f)(double, double*));
double dfdx(double x, double* params, double (*f)(double, double*));

#endif============================================
src/thomas_alg.h
05:25:51_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : thomas_alg.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <math.h>

#ifndef THOMAS_ALG_H
#define THOMAS_ALG_H

#define COMPUTE_A_S_START 1
#define COMPUTE_Q_S_START 1
#define COMPUTE_x_END 1

#define THOMAS_INIT_ARR_LEN 20
#define TINY(x) fabs(x) < 1e-11
#define SOLVER_FAIL -1
#define SOLVER_SUCCESS 1

// represents a row in a tridiagonal linear system
typedef struct tridiag_row_struct {

    double a;
    double b;
    double c;
    double Q;
    double a_s;
    double Q_s;
    double x;

} tridiag_row_t;

// represents a tridiagonal linear system
typedef struct tridiag_struct {

    tridiag_row_t *rows;
    int N;
    int arrLen;

} tridiag_t;

tridiag_t *newTridiag();
void freeTridiag(tridiag_t *m);
void appendTridiagRow(tridiag_t *m, double a, double b, double c, double Q);
tridiag_row_t *getTridiagRow(tridiag_t *m, int i); //retrieve the ith row
int solveTridiag(tridiag_t *m);

int computeTridiag_a_s(tridiag_t *m);
int computeTridiag_Q_s(tridiag_t *m);
int computeTrigiag_x(tridiag_t *m);

#endif============================================
src/interpolate.c
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : interpolate.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "interpolate.h"

// Create a new data set
interp_set_t* newInterpSet() {

	interp_set_t* newSet = (interp_set_t*)malloc(sizeof(interp_set_t));
	assert( newSet!= NULL );

	newSet->pts = (interp_pt_t**)malloc(INTERP_INIT_ARRLEN*sizeof(interp_pt_t*));
	assert( newSet->pts != NULL);

	newSet->arrLen = INTERP_INIT_ARRLEN;
	newSet->N = 0;

	return newSet;
}

// Create a new point
interp_pt_t* newInterpPt(double x, double fx) {

	interp_pt_t* newPt = (interp_pt_t*)malloc(sizeof(interp_pt_t));
	assert(newPt != NULL);

	newPt->x = x;
	newPt->fx = fx;

	return newPt;
}

// Frees a set (including points)
void freeInterpSet(interp_set_t* set) {
	assert(set!=NULL);
	
	int i=0;
	for(i=0; i < set->N ; i++) {
		freeInterpPt(set->pts[i]);
	}
	free(set->pts);
	free(set);
}

// frees an interpolation point
void freeInterpPt(interp_pt_t* pt) {
	assert(pt!=NULL);
	free(pt);
}

// appends a new point to the set
void appendPtToSet(interp_set_t* set, interp_pt_t* pt) {

	assert(set!=NULL);
	assert(pt!=NULL);

	// extend array if necessary
	if( set->N >= set->arrLen) {
		set->arrLen += INTERP_INIT_ARRLEN;
		int newSize = set->arrLen * sizeof(interp_pt_t*);
		set->pts = (interp_pt_t**)realloc(set->pts, newSize );
	}

	// insert new pt
	set->pts[set->N] = pt;
	set->N++;
}

// generates a lagrange term based on a point in the set
lagrange_term_t* newLagrangeTerm(interp_set_t* set, int index) {

	assert(set!=NULL);

	// initialise new lgrange_term_t
	lagrange_term_t* newTerm = (lagrange_term_t*)malloc(sizeof(lagrange_term_t));
	assert(newTerm != NULL);

	newTerm->order = set->N-1;
	newTerm->index = index;
	newTerm->fx_i = (set->pts[index])->fx;

	newTerm->root = (double*)calloc(newTerm->order+1, sizeof(double));
	assert(newTerm->root!=NULL);

	// calculate denominator
	newTerm->denominator = 1;
	interp_pt_t** pts = set->pts;
	int i=0;
	for(i=0; i <= newTerm->order ; i++) {
		if (i == index) { continue; }
		newTerm->denominator *= ((pts[index])->x - (pts[i])->x);
	}

	// calculate roots
	for(i=0; i <= newTerm->order ; i++) {
		if (i == index) { continue; }
		newTerm->root[i] = (pts[i])->x;
	}

	return newTerm;
}

// generates a lagrange eqn based on a set
lagrange_eqn_t* newLagrangeEqn(interp_set_t* set) {

	assert(set!=NULL);

	// initialise new lagrange_eqn_t
	lagrange_eqn_t* newEqn = (lagrange_eqn_t*)malloc(sizeof(lagrange_eqn_t));
	assert(newEqn != NULL);

	newEqn->num_terms = set->N;

	int arrSize = newEqn->num_terms * sizeof(lagrange_term_t*);
	newEqn->terms = (lagrange_term_t**)malloc(arrSize);
	assert(newEqn->terms != NULL);

	// generate terms
	int i=0;
	for (i=0; i < newEqn->num_terms ; i++) {
		newEqn->terms[i] = newLagrangeTerm(set, i);
	}

	return newEqn;
}

// frees lagrange eqn structure
void freeLagrangeEqn(lagrange_eqn_t* eqn) {
	
	assert(eqn!=NULL);

	// generate terms
	int i=0;
	for (i=0; i < eqn->num_terms ; i++) {
		freeLagrangeTerm(eqn->terms[i]);
	}

	free(eqn->terms);
	free(eqn);
}

// frees lagrange term struct
void freeLagrangeTerm(lagrange_term_t* term) {
	
	assert(term!=NULL);
	free(term->root);
	free(term);
}

// evaluates a lagrange equation at x
interp_pt_t* evaluateLagrangeEqn(lagrange_eqn_t* eqn, double x) {

	assert(eqn!=NULL);

	double fx = 0;

	// sum of evaluated terms
	int i=0;
	for(i=0; i < eqn->num_terms ; i++) {
		fx += evaluateLagrangeTerm(eqn->terms[i],x);
	}

	return newInterpPt(x, fx);
}

// evaluate lagrange term at x
double evaluateLagrangeTerm(lagrange_term_t* term, double x) {

	assert(term!=NULL);
	
	double numerator = term->fx_i;

	int i=0;
	for(i=0; i <= term->order; i++) {
		if(i == term->index) { continue; }
		numerator *= (x - term->root[i]);
	}

	return numerator/term->denominator;
}

// generates a set of cubic splines from a set
cub_spline_t* newCubSpline(interp_set_t* set) {

	assert(set!=NULL);

	cub_spline_t* spline = (cub_spline_t*)malloc(sizeof(cub_spline_t));
	assert(spline!=NULL);

	int segsSize = (set->N)*sizeof(cub_spline_seg_t*);
	spline->segs = (cub_spline_seg_t**)malloc(segsSize);
	assert(spline->segs != NULL);

	spline->num_segs = set->N-1;

	int i=0;
	for(i=0; i < set->N; i++) {
		spline->segs[i] = newEmptyCubSplineSegment(i, (set->pts[i])->x);
	}

	// compute the segment constants
	assert(CUB_SPLINE_COMPUTE_SUCCESS == computeCubSplineConstants(set, spline));

	return spline;
}

// generate a new empty spline segment
cub_spline_seg_t* newEmptyCubSplineSegment(int index, double x_lo) {

	cub_spline_seg_t* seg = (cub_spline_seg_t*)malloc(sizeof(cub_spline_seg_t));
	assert(seg!=NULL);

	seg->index = index;
	seg->x_lo = x_lo;
	seg->a = 0;
	seg->b = 0;
	seg->c = 0;
	seg->d = 0;

	return seg;
}

// free a cubic spline structure including segments
void freeCubSpline(cub_spline_t* spline) {

	assert(spline!=NULL);

	int i=0;
	for (i=0; i<= spline->num_segs; i++) {
		freeCubSplineSegment(spline->segs[i]);
	}

	free(spline->segs);
	free(spline);
}

// free a cubic spline segment structure
void freeCubSplineSegment(cub_spline_seg_t* seg) {
	assert(seg!=NULL);
	free(seg);
}

// get the spline h_i value
double splineH(int index, cub_spline_t* spline) {

	assert(spline!=NULL);
	assert(index < spline->num_segs);

	double x_lo = (spline->segs[index])->x_lo;
	double x_hi = (spline->segs[index+1])->x_lo;

	return x_hi - x_lo;
}

// compute the spline segment constants
int computeCubSplineConstants(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	int successFlag = CUB_SPLINE_COMPUTE_SUCCESS;

	if( computeCubSplineAs(set, spline) == successFlag && 
		computeCubSplineCs(set, spline) == successFlag && 
		computeCubSplineBs(set, spline) == successFlag && 
		computeCubSplineDs(set, spline) == successFlag
	) {
		return successFlag;
	}
	
	return CUB_SPLINE_COMPUTE_FAIL;
}

// compute spline a's
int computeCubSplineAs(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	int i=0;
	for(i=0; i <=spline->num_segs; i++) {
		(spline->segs[i])->a = (set->pts[i])->fx;
	}

	return CUB_SPLINE_COMPUTE_SUCCESS;
}

// compute spline b's
int computeCubSplineBs(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	int i=0;
	double h_i, a_i, a_ip, c_i, c_ip;
	for(i=0; i <spline->num_segs; i++) {

		h_i = splineH(i,spline);
		a_i = (spline->segs[i])->a;
		a_ip = (spline->segs[i+1])->a;
		c_i = (spline->segs[i])->c;
		c_ip = (spline->segs[i+1])->c;

		if(TINY(h_i)) { return CUB_SPLINE_COMPUTE_FAIL; }

		(spline->segs[i])->b = CUB_SPLINE_B(h_i, a_i, a_ip, c_i, c_ip);
	}
	
	return CUB_SPLINE_COMPUTE_SUCCESS;
}

// compute spline c's by solving a tridiagonal matrix
int computeCubSplineCs(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	// generate tridiag matrix
	tridiag_t *m = newTridiag();
	appendTridiagRow(m, 1.0, 0, 0, 0);
	
	int i=0;
	double h_im, h_i,  a_im, a_i, a_ip;
	double a, b, c, Q;
	for(i=1; i<spline->num_segs; i++) {
		h_im = splineH(i-1,spline);
		h_i = splineH(i,spline);
		a_im = (spline->segs[i-1])->a;
		a_i = (spline->segs[i])->a;
		a_ip = (spline->segs[i+1])->a;

		a = CUB_SPLINE_C_a(h_i, h_im);
		b = h_i;
		c = h_im;
		Q = CUB_SPLINE_C_RHS(h_im, h_i, a_im, a_i, a_ip);

		appendTridiagRow(m, a, b, c, Q);
	}
	appendTridiagRow(m, 1.0, 0, 0, 0);

	// solve tridiag
	if (solveTridiag(m) != SOLVER_SUCCESS) {
		freeTridiag(m);
		return CUB_SPLINE_COMPUTE_FAIL;
	}

	// load c's into spline
	for(i=0; i<=spline->num_segs; i++) {
		(spline->segs[i])->c = getTridiagRow(m, i+1)->x;
	}

	freeTridiag(m);

	return CUB_SPLINE_COMPUTE_SUCCESS;
}

// compute spline d's
int computeCubSplineDs(interp_set_t* set, cub_spline_t* spline) {

	assert(set!=NULL);
	assert(spline!=NULL);

	int i=0;
	double h_i, c_i, c_ip;
	for(i=0; i<spline->num_segs; i++) {

		h_i = splineH(i,spline);
		c_i = (spline->segs[i])->c;
		c_ip = (spline->segs[i+1])->c;

		if(TINY(h_i)) { return CUB_SPLINE_COMPUTE_FAIL; }

		(spline->segs[i])->d = CUB_SPLINE_D(h_i, c_i, c_ip);
	}

	return CUB_SPLINE_COMPUTE_SUCCESS;
}

// evaluate a spline at x
interp_pt_t* evaluateCubSpline(cub_spline_t* spline, double x) {

	assert(spline!=NULL);

	double x_lo = (spline->segs[0])->x_lo;
	double x_hi = (spline->segs[spline->num_segs])->x_lo;
	assert(x>=x_lo && x<=x_hi);

	// find relevant segment
	int i=0;
	while(x>=x_lo) {
		i++;
		x_lo = (spline->segs[i])->x_lo;
	}

	// calculate value
	return evaluateCubSplineSegment(spline->segs[i-1], x);
}

// evaluate a cubic spline segment at x
interp_pt_t* evaluateCubSplineSegment(cub_spline_seg_t* seg, double x) {
	
	assert(seg!=NULL);
	double fx = EVAL_CUB_SPLINE(seg->a, seg->b, seg->c, seg->d, seg->x_lo, x);
	return newInterpPt(x, fx);
}

============================================
src/thomas_alg.c
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : thomas_alg.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "thomas_alg.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>

// create a new tridiagonal matrix linear system structure
tridiag_t *newTridiag() {
	
	tridiag_t *m = (tridiag_t*)malloc(sizeof(tridiag_t));
	assert(m != NULL);

	m->arrLen = THOMAS_INIT_ARR_LEN;
	m->N = 0;

	m->rows = (tridiag_row_t*)calloc( m->arrLen, sizeof(tridiag_row_t));
	assert(m->rows != NULL);

	return m;
}

// free a tridiagonal matrix structure
void freeTridiag(tridiag_t *m) {
	assert(m!=NULL);
	free(m->rows);
	free(m);
}

// add a row onto the bottom of a tridiagonal matrix
void appendTridiagRow(tridiag_t *m, double a, double b, double c, double Q) {

	assert(m!=NULL);	

	m->N++;
	if(m->N == m->arrLen) {
		m->arrLen += THOMAS_INIT_ARR_LEN;
		m->rows = (tridiag_row_t*)realloc( m->rows, m->arrLen*sizeof(tridiag_row_t));
		assert(m->rows!=NULL);
	}

	tridiag_row_t *r = getTridiagRow(m, m->N);
	r->a = a;
	r->b = b;
	r->c = c;
	r->Q = Q;
}

// get a row of a tridiagonal matrix
tridiag_row_t *getTridiagRow(tridiag_t *m, int i) {
	assert(m!=NULL);
	assert(i<=m->N);
	return &(m->rows[i-1]);
}

// Use thomas algorithm to solve a tridiagonal linear system
int solveTridiag(tridiag_t *m) {

	assert(m!=NULL);
	
	if(
		computeTridiag_a_s(m) == SOLVER_SUCCESS &&
		computeTridiag_Q_s(m) == SOLVER_SUCCESS &&
		computeTrigiag_x(m) == SOLVER_SUCCESS
	) {
		return SOLVER_SUCCESS;
	}

	return SOLVER_FAIL;
}

// compute the a_s values for the tridiagonal linear system
int computeTridiag_a_s(tridiag_t *m) {

	assert(m!=NULL);

	// case for row 1 : a_s = a
	int i=COMPUTE_A_S_START;
	tridiag_row_t *r = getTridiagRow(m, i);	
	tridiag_row_t *rPrev = r;
	r->a_s = r->a;

	// case for row 2,3,4...N : a_s = a − c * bPrev / a_sPrev
	while(++i <= m->N) {
		rPrev = r;
		r = getTridiagRow(m, i);
		if(TINY(rPrev->a_s)) { return SOLVER_FAIL; }
		r->a_s = r->a - r->c * rPrev->b / rPrev->a_s;
	}

	return SOLVER_SUCCESS;
}

// compute the Q_s values for the tridiagonal linear system
int computeTridiag_Q_s(tridiag_t *m) {
	
	assert(m!=NULL);

	// case for row 1 : Q_s = Q
	int i=COMPUTE_Q_S_START;
	tridiag_row_t *r = getTridiagRow(m, i);	
	tridiag_row_t *rPrev = r;
	r->Q_s = r->Q;

	// case for row 2,3,4...N : Q − c * Q_sPrev /a_sPrev
	while(++i <= m->N) {
		rPrev = r;
		r = getTridiagRow(m, i);
		if(TINY(rPrev->a_s)) { return SOLVER_FAIL; }
		r->Q_s = r->Q - r->c * rPrev->Q_s / rPrev->a_s;
	}

	return SOLVER_SUCCESS;
}

// compute the x values for the tridiagonal linear system
int computeTrigiag_x(tridiag_t *m) {
	
	assert(m!=NULL);
	
	// case for row N : x = Q_s/a_s
	int i=m->N;
	tridiag_row_t *r = getTridiagRow(m, i);	
	tridiag_row_t *rPrev = r;
	r->x = r->Q_s/r->a_s;

	// case for row N-1, N-2, N-3...1 : x = ( Q_s − b * xPrev ) / a_s
	while(--i >= COMPUTE_x_END) {
		rPrev = r;
		r = getTridiagRow(m, i);
		if(TINY(rPrev->a_s)) { return SOLVER_FAIL; }
		r->x = (r->Q_s - r->b * rPrev->x) / r->a_s;
	}

	return SOLVER_SUCCESS;
}============================================
src/newton_raphson.c
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : newton_raphson.c
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include "newton_raphson.h"

// simple newton raphson implementation
int newtonRaphson(double* xi, double* params, double (*f)(double, double*)) {

    double fx = f((*xi), params);

    int i=0;
    while( (i < MAX_ITERATIONS) && (fabs(fx) > EPS) ) {

        fx = f((*xi), params);
        (*xi) = (*xi) - fx / dfdx((*xi), params, f);

        i++;
    }

    if (fabs(fx) > EPS) { 
        return ROOTFIND_FAIL;
    }

    return i;
}

// simple derivative approximation
double dfdx(double x, double* params, double (*f)(double, double*)) {

    double df = f(x+DX/2, params) - f(x-DX/2, params);
    return df/(DX);
}============================================
src/tasks.h
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : tasks.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#include "newton_raphson.h"
#include "thomas_alg.h"
#include "interpolate.h"
#include "heat_sim.h"

#ifndef TASKS_H

#define FILE_READONLY "r"
#define FILE_OVERWRITE "w"

#define PI 3.14159265359
#define DEG2RAD(deg) deg * PI / 180.0
#define RAD2DEG(rad) rad * 180.0 / PI

// used for shockwave question
#define NUM_PARAMS_2 5
#define F_M_2 0
#define F_T_2 1
#define F_G_2 2
#define F_2(b,M,t,g) (2.0/tan(b)) * (pow(M*sin(b), 2.0) - 1.0) / (M*M*(g + cos(2.0*b)) + 2.0) - tan(t)
#define B_l_GUESS_2 20.0
#define B_u_GUESS_2 90.0
#define IN_1ST_HEADER_2 "M,theta,beta_l,beta_u,gamma\n"
#define IN_2ND_HEADER_2 "M\n"
#define FILENAME_2B "my_2b.csv"
#define FILENAME_2C "out_shock.csv"
#define FILE_HEADER_2BC "M,theta,beta_lower,beta_upper\n"
#define RADIAN_START_2B 0
#define RADIAN_INCREMENT_2B DEG2RAD(1)
#define M_LEN_2C 20

// used for linear algebra question
#define NUM_PARAMS_3 4
#define FILENAME_3 "out_linalsys.csv"
#define FILE_HEADER_3 "x\n"
#define IN_HEADER_3 "a,b,c,q\n"

// used for interpolation question
#define NUM_PARAMS_5 2
#define IN_HEADER_5 "x,f(x)\n"
#define PLOT_FILENAME_ANY_ORDER_5 "my_any_order_5.csv"
#define PLOT_FILENAME_QUADRATIC_5 "my_quadratic_5.csv"
#define FILENAME_5 "out_interp.csv"
#define PLOT_START_5 0
#define PLOT_END_5 8
#define PLOT_INTERVAL_5 0.01
#define PLOT_HEADER_LAGRANGE_5 "x,lagrange,spline\n"
#define HEADER_LAGRANGE_5 "lagrange\n"
#define HEADER_CUBIC_5 "cubic\n"

// used for heat equation question
#define NUM_PARAMS_6 3
#define X_LO_6 0.0
#define X_HI_6 1.0
#define T_LO_6 0.0
#define T_HI_6 2.0
#define IC_LO_6 0.125
#define IC_6(x) 0.5*(1.0-cos(8.0*PI*(x - 0.125)))
#define IC_HI_6 0.375
#define IN_HEADER_6 "mu,Nx,Nt\n"
#define OUT_HEADER_6 "x,f(x)\n"
#define FILENAME_EX_FE_6 "out_heateqn_explicit_fe.csv"
#define FILENAME_EX_VE_6 "out_heateqn_explicit_ve.csv"
#define FILENAME_IM_FE_6 "out_heateqn_implicit_fe.csv"

// Input type for shockwave question (Question 2)
typedef struct input_2 {

	double M_a;
	double t_a;
	double g_a;
	double b_l_a;
	double b_u_a;
	double *M_c;
	int num_M_c;

} input_2_t;


/* * * * * * * * * * * * * * * * * * * * * * * * * *  HEATEQN HELPER FUNCTIONS */

heat_sim_t* parseInput_6(const char* filename);
double myInitialCondition_6(double x);
void printSim_6(heat_sim_t* sim, const char* filename);


/* * * * * * * * * * * * * * * * * * * * * * * * * *  INTERP HELPER FUNCTIONS */

interp_set_t* parseInput_5(const char* filename);
interp_pt_t* evaluateQuadLagrangeEqn(interp_set_t* set, double xo);
void printInterp_5(double lag, double spline);
void plotInterpAnyOrder_5(lagrange_eqn_t* lagEqn, cub_spline_t* splineEqn);
void plotInterpQuadratic_5(interp_set_t* set, cub_spline_t* splineEqn);


/* * * * * * * * * * * * * * * * * * * * * * * * LINALGBYSYS HELPER FUNCTIONS */

tridiag_t *parseInput_3(const char* filename);
void printTridiag_3(tridiag_t *m);


/* * * * * * * * * * * * * * * * * * * * * * * * * SHOCKWAVE HELPER FUNCTIONS */

input_2_t *parseInput_2(const char* filename);
void parseInput2ndLine_2(FILE* fp, input_2_t* parsed);
void parseInputMvals_2(FILE* fp, input_2_t* parsed);
void freeInput_2(input_2_t *parsed);
double f_2(double beta, double* params);
void shockwave_2a(const input_2_t *parsed);
void shockwave_2b(const input_2_t *parsed);
void shockwave_2c(const input_2_t *parsed);


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * TASK FUNCTIONS */

void shockwave(const char* q2_file);
void linalgbsys(const char* q4_file);
void interp(const char* q5_file, const double xo);
void heateqn(const char* q6_file);


#endif
============================================
src/heat_sim.h
05:25:50_Monday_16_October_2017
============================================
/***************************************************************************
 *
 *   File        : heat_sim.h
 *   Student Id  : 757931
 *   Name        : Sebastian Baker
 *
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "thomas_alg.h"

#ifndef HEAT_SIM_H

#define EXPLICIT_RHS(mu, dx, f_0, f_1, f_2) mu*(f_2 - 2.0*f_1 + f_0)/(dx*dx)

// heat simulation cell
typedef struct heat_cell {

    double f;
    double x;
    double t;

} sim_cell_t;

// heat simulation struct
typedef struct heat_sim {

    sim_cell_t** cells; // matrix of cells, in the form f(x,t) = cells[i_x][j_t]
    double mu;
    double x_lo;
    double x_hi;
    double t_lo;
    double t_hi;
    int Nx;  // not including 0th x value
    int Nt; // not including 0th t value

} heat_sim_t;

heat_sim_t* newUnsolvedHeatSim(
    int Nx, 
    int Nt, 
    double x_lo, 
    double x_hi,
    double t_lo,
    double t_hi,
    double mu, 
    double (*init)(double x) 
);

void freeHeatSim(heat_sim_t* sim);
void eulerExFe(heat_sim_t* sim);
void eulerExVe(heat_sim_t* sim);
void eulerImFe(heat_sim_t* sim);


#endif 